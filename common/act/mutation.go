// Code generated by ent, DO NOT EDIT.

package act

import (
	"act/common/act/execution"
	"act/common/act/identitylink"
	"act/common/act/predicate"
	"act/common/act/procdef"
	"act/common/act/procinst"
	"act/common/act/task"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeExecution    = "Execution"
	TypeIdentityLink = "IdentityLink"
	TypeProcDef      = "ProcDef"
	TypeProcInst     = "ProcInst"
	TypeTask         = "Task"
)

// ExecutionMutation represents an operation that mutates the Execution nodes in the graph.
type ExecutionMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	proc_inst_id    *int64
	addproc_inst_id *int64
	proc_def_id     *int64
	addproc_def_id  *int64
	node_infos      *string
	start_time      *time.Time
	is_del          *int8
	addis_del       *int8
	create_time     *time.Time
	update_time     *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Execution, error)
	predicates      []predicate.Execution
}

var _ ent.Mutation = (*ExecutionMutation)(nil)

// executionOption allows management of the mutation configuration using functional options.
type executionOption func(*ExecutionMutation)

// newExecutionMutation creates new mutation for the Execution entity.
func newExecutionMutation(c config, op Op, opts ...executionOption) *ExecutionMutation {
	m := &ExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExecutionID sets the ID field of the mutation.
func withExecutionID(id int64) executionOption {
	return func(m *ExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *Execution
		)
		m.oldValue = func(ctx context.Context) (*Execution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Execution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExecution sets the old Execution of the mutation.
func withExecution(node *Execution) executionOption {
	return func(m *ExecutionMutation) {
		m.oldValue = func(context.Context) (*Execution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("act: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExecutionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExecutionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Execution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProcInstID sets the "proc_inst_id" field.
func (m *ExecutionMutation) SetProcInstID(i int64) {
	m.proc_inst_id = &i
	m.addproc_inst_id = nil
}

// ProcInstID returns the value of the "proc_inst_id" field in the mutation.
func (m *ExecutionMutation) ProcInstID() (r int64, exists bool) {
	v := m.proc_inst_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcInstID returns the old "proc_inst_id" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldProcInstID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcInstID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcInstID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcInstID: %w", err)
	}
	return oldValue.ProcInstID, nil
}

// AddProcInstID adds i to the "proc_inst_id" field.
func (m *ExecutionMutation) AddProcInstID(i int64) {
	if m.addproc_inst_id != nil {
		*m.addproc_inst_id += i
	} else {
		m.addproc_inst_id = &i
	}
}

// AddedProcInstID returns the value that was added to the "proc_inst_id" field in this mutation.
func (m *ExecutionMutation) AddedProcInstID() (r int64, exists bool) {
	v := m.addproc_inst_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcInstID resets all changes to the "proc_inst_id" field.
func (m *ExecutionMutation) ResetProcInstID() {
	m.proc_inst_id = nil
	m.addproc_inst_id = nil
}

// SetProcDefID sets the "proc_def_id" field.
func (m *ExecutionMutation) SetProcDefID(i int64) {
	m.proc_def_id = &i
	m.addproc_def_id = nil
}

// ProcDefID returns the value of the "proc_def_id" field in the mutation.
func (m *ExecutionMutation) ProcDefID() (r int64, exists bool) {
	v := m.proc_def_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcDefID returns the old "proc_def_id" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldProcDefID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcDefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcDefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcDefID: %w", err)
	}
	return oldValue.ProcDefID, nil
}

// AddProcDefID adds i to the "proc_def_id" field.
func (m *ExecutionMutation) AddProcDefID(i int64) {
	if m.addproc_def_id != nil {
		*m.addproc_def_id += i
	} else {
		m.addproc_def_id = &i
	}
}

// AddedProcDefID returns the value that was added to the "proc_def_id" field in this mutation.
func (m *ExecutionMutation) AddedProcDefID() (r int64, exists bool) {
	v := m.addproc_def_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcDefID resets all changes to the "proc_def_id" field.
func (m *ExecutionMutation) ResetProcDefID() {
	m.proc_def_id = nil
	m.addproc_def_id = nil
}

// SetNodeInfos sets the "node_infos" field.
func (m *ExecutionMutation) SetNodeInfos(s string) {
	m.node_infos = &s
}

// NodeInfos returns the value of the "node_infos" field in the mutation.
func (m *ExecutionMutation) NodeInfos() (r string, exists bool) {
	v := m.node_infos
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeInfos returns the old "node_infos" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldNodeInfos(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeInfos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeInfos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeInfos: %w", err)
	}
	return oldValue.NodeInfos, nil
}

// ClearNodeInfos clears the value of the "node_infos" field.
func (m *ExecutionMutation) ClearNodeInfos() {
	m.node_infos = nil
	m.clearedFields[execution.FieldNodeInfos] = struct{}{}
}

// NodeInfosCleared returns if the "node_infos" field was cleared in this mutation.
func (m *ExecutionMutation) NodeInfosCleared() bool {
	_, ok := m.clearedFields[execution.FieldNodeInfos]
	return ok
}

// ResetNodeInfos resets all changes to the "node_infos" field.
func (m *ExecutionMutation) ResetNodeInfos() {
	m.node_infos = nil
	delete(m.clearedFields, execution.FieldNodeInfos)
}

// SetStartTime sets the "start_time" field.
func (m *ExecutionMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ExecutionMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ExecutionMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[execution.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ExecutionMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[execution.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ExecutionMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, execution.FieldStartTime)
}

// SetIsDel sets the "is_del" field.
func (m *ExecutionMutation) SetIsDel(i int8) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *ExecutionMutation) IsDel() (r int8, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldIsDel(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *ExecutionMutation) AddIsDel(i int8) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *ExecutionMutation) AddedIsDel() (r int8, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsDel clears the value of the "is_del" field.
func (m *ExecutionMutation) ClearIsDel() {
	m.is_del = nil
	m.addis_del = nil
	m.clearedFields[execution.FieldIsDel] = struct{}{}
}

// IsDelCleared returns if the "is_del" field was cleared in this mutation.
func (m *ExecutionMutation) IsDelCleared() bool {
	_, ok := m.clearedFields[execution.FieldIsDel]
	return ok
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *ExecutionMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
	delete(m.clearedFields, execution.FieldIsDel)
}

// SetCreateTime sets the "create_time" field.
func (m *ExecutionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ExecutionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ExecutionMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[execution.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ExecutionMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[execution.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ExecutionMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, execution.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *ExecutionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ExecutionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Execution entity.
// If the Execution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *ExecutionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[execution.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *ExecutionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[execution.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ExecutionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, execution.FieldUpdateTime)
}

// Where appends a list predicates to the ExecutionMutation builder.
func (m *ExecutionMutation) Where(ps ...predicate.Execution) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExecutionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Execution).
func (m *ExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExecutionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.proc_inst_id != nil {
		fields = append(fields, execution.FieldProcInstID)
	}
	if m.proc_def_id != nil {
		fields = append(fields, execution.FieldProcDefID)
	}
	if m.node_infos != nil {
		fields = append(fields, execution.FieldNodeInfos)
	}
	if m.start_time != nil {
		fields = append(fields, execution.FieldStartTime)
	}
	if m.is_del != nil {
		fields = append(fields, execution.FieldIsDel)
	}
	if m.create_time != nil {
		fields = append(fields, execution.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, execution.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case execution.FieldProcInstID:
		return m.ProcInstID()
	case execution.FieldProcDefID:
		return m.ProcDefID()
	case execution.FieldNodeInfos:
		return m.NodeInfos()
	case execution.FieldStartTime:
		return m.StartTime()
	case execution.FieldIsDel:
		return m.IsDel()
	case execution.FieldCreateTime:
		return m.CreateTime()
	case execution.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case execution.FieldProcInstID:
		return m.OldProcInstID(ctx)
	case execution.FieldProcDefID:
		return m.OldProcDefID(ctx)
	case execution.FieldNodeInfos:
		return m.OldNodeInfos(ctx)
	case execution.FieldStartTime:
		return m.OldStartTime(ctx)
	case execution.FieldIsDel:
		return m.OldIsDel(ctx)
	case execution.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case execution.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Execution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case execution.FieldProcInstID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcInstID(v)
		return nil
	case execution.FieldProcDefID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcDefID(v)
		return nil
	case execution.FieldNodeInfos:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeInfos(v)
		return nil
	case execution.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case execution.FieldIsDel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case execution.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case execution.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Execution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addproc_inst_id != nil {
		fields = append(fields, execution.FieldProcInstID)
	}
	if m.addproc_def_id != nil {
		fields = append(fields, execution.FieldProcDefID)
	}
	if m.addis_del != nil {
		fields = append(fields, execution.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case execution.FieldProcInstID:
		return m.AddedProcInstID()
	case execution.FieldProcDefID:
		return m.AddedProcDefID()
	case execution.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case execution.FieldProcInstID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcInstID(v)
		return nil
	case execution.FieldProcDefID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcDefID(v)
		return nil
	case execution.FieldIsDel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown Execution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(execution.FieldNodeInfos) {
		fields = append(fields, execution.FieldNodeInfos)
	}
	if m.FieldCleared(execution.FieldStartTime) {
		fields = append(fields, execution.FieldStartTime)
	}
	if m.FieldCleared(execution.FieldIsDel) {
		fields = append(fields, execution.FieldIsDel)
	}
	if m.FieldCleared(execution.FieldCreateTime) {
		fields = append(fields, execution.FieldCreateTime)
	}
	if m.FieldCleared(execution.FieldUpdateTime) {
		fields = append(fields, execution.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExecutionMutation) ClearField(name string) error {
	switch name {
	case execution.FieldNodeInfos:
		m.ClearNodeInfos()
		return nil
	case execution.FieldStartTime:
		m.ClearStartTime()
		return nil
	case execution.FieldIsDel:
		m.ClearIsDel()
		return nil
	case execution.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case execution.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Execution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExecutionMutation) ResetField(name string) error {
	switch name {
	case execution.FieldProcInstID:
		m.ResetProcInstID()
		return nil
	case execution.FieldProcDefID:
		m.ResetProcDefID()
		return nil
	case execution.FieldNodeInfos:
		m.ResetNodeInfos()
		return nil
	case execution.FieldStartTime:
		m.ResetStartTime()
		return nil
	case execution.FieldIsDel:
		m.ResetIsDel()
		return nil
	case execution.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case execution.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Execution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExecutionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExecutionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExecutionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Execution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExecutionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Execution edge %s", name)
}

// IdentityLinkMutation represents an operation that mutates the IdentityLink nodes in the graph.
type IdentityLinkMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	user_id         *int64
	adduser_id      *int64
	user_name       *string
	step            *int
	addstep         *int
	proc_inst_id    *int64
	addproc_inst_id *int64
	target_id       *int64
	addtarget_id    *int64
	comment         *string
	task_id         *int64
	addtask_id      *int64
	result          *int
	addresult       *int
	create_time     *time.Time
	is_del          *int8
	addis_del       *int8
	is_deal         *int8
	addis_deal      *int8
	update_time     *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*IdentityLink, error)
	predicates      []predicate.IdentityLink
}

var _ ent.Mutation = (*IdentityLinkMutation)(nil)

// identitylinkOption allows management of the mutation configuration using functional options.
type identitylinkOption func(*IdentityLinkMutation)

// newIdentityLinkMutation creates new mutation for the IdentityLink entity.
func newIdentityLinkMutation(c config, op Op, opts ...identitylinkOption) *IdentityLinkMutation {
	m := &IdentityLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentityLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentityLinkID sets the ID field of the mutation.
func withIdentityLinkID(id int64) identitylinkOption {
	return func(m *IdentityLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *IdentityLink
		)
		m.oldValue = func(ctx context.Context) (*IdentityLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IdentityLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentityLink sets the old IdentityLink of the mutation.
func withIdentityLink(node *IdentityLink) identitylinkOption {
	return func(m *IdentityLinkMutation) {
		m.oldValue = func(context.Context) (*IdentityLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentityLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentityLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("act: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentityLinkMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentityLinkMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IdentityLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *IdentityLinkMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IdentityLinkMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *IdentityLinkMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *IdentityLinkMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *IdentityLinkMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[identitylink.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *IdentityLinkMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IdentityLinkMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, identitylink.FieldUserID)
}

// SetUserName sets the "user_name" field.
func (m *IdentityLinkMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *IdentityLinkMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "user_name" field.
func (m *IdentityLinkMutation) ClearUserName() {
	m.user_name = nil
	m.clearedFields[identitylink.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "user_name" field was cleared in this mutation.
func (m *IdentityLinkMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "user_name" field.
func (m *IdentityLinkMutation) ResetUserName() {
	m.user_name = nil
	delete(m.clearedFields, identitylink.FieldUserName)
}

// SetStep sets the "step" field.
func (m *IdentityLinkMutation) SetStep(i int) {
	m.step = &i
	m.addstep = nil
}

// Step returns the value of the "step" field in the mutation.
func (m *IdentityLinkMutation) Step() (r int, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStep returns the old "step" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldStep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStep: %w", err)
	}
	return oldValue.Step, nil
}

// AddStep adds i to the "step" field.
func (m *IdentityLinkMutation) AddStep(i int) {
	if m.addstep != nil {
		*m.addstep += i
	} else {
		m.addstep = &i
	}
}

// AddedStep returns the value that was added to the "step" field in this mutation.
func (m *IdentityLinkMutation) AddedStep() (r int, exists bool) {
	v := m.addstep
	if v == nil {
		return
	}
	return *v, true
}

// ClearStep clears the value of the "step" field.
func (m *IdentityLinkMutation) ClearStep() {
	m.step = nil
	m.addstep = nil
	m.clearedFields[identitylink.FieldStep] = struct{}{}
}

// StepCleared returns if the "step" field was cleared in this mutation.
func (m *IdentityLinkMutation) StepCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldStep]
	return ok
}

// ResetStep resets all changes to the "step" field.
func (m *IdentityLinkMutation) ResetStep() {
	m.step = nil
	m.addstep = nil
	delete(m.clearedFields, identitylink.FieldStep)
}

// SetProcInstID sets the "proc_inst_id" field.
func (m *IdentityLinkMutation) SetProcInstID(i int64) {
	m.proc_inst_id = &i
	m.addproc_inst_id = nil
}

// ProcInstID returns the value of the "proc_inst_id" field in the mutation.
func (m *IdentityLinkMutation) ProcInstID() (r int64, exists bool) {
	v := m.proc_inst_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcInstID returns the old "proc_inst_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldProcInstID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcInstID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcInstID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcInstID: %w", err)
	}
	return oldValue.ProcInstID, nil
}

// AddProcInstID adds i to the "proc_inst_id" field.
func (m *IdentityLinkMutation) AddProcInstID(i int64) {
	if m.addproc_inst_id != nil {
		*m.addproc_inst_id += i
	} else {
		m.addproc_inst_id = &i
	}
}

// AddedProcInstID returns the value that was added to the "proc_inst_id" field in this mutation.
func (m *IdentityLinkMutation) AddedProcInstID() (r int64, exists bool) {
	v := m.addproc_inst_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcInstID resets all changes to the "proc_inst_id" field.
func (m *IdentityLinkMutation) ResetProcInstID() {
	m.proc_inst_id = nil
	m.addproc_inst_id = nil
}

// SetTargetID sets the "target_id" field.
func (m *IdentityLinkMutation) SetTargetID(i int64) {
	m.target_id = &i
	m.addtarget_id = nil
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *IdentityLinkMutation) TargetID() (r int64, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldTargetID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// AddTargetID adds i to the "target_id" field.
func (m *IdentityLinkMutation) AddTargetID(i int64) {
	if m.addtarget_id != nil {
		*m.addtarget_id += i
	} else {
		m.addtarget_id = &i
	}
}

// AddedTargetID returns the value that was added to the "target_id" field in this mutation.
func (m *IdentityLinkMutation) AddedTargetID() (r int64, exists bool) {
	v := m.addtarget_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetID clears the value of the "target_id" field.
func (m *IdentityLinkMutation) ClearTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	m.clearedFields[identitylink.FieldTargetID] = struct{}{}
}

// TargetIDCleared returns if the "target_id" field was cleared in this mutation.
func (m *IdentityLinkMutation) TargetIDCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldTargetID]
	return ok
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *IdentityLinkMutation) ResetTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	delete(m.clearedFields, identitylink.FieldTargetID)
}

// SetComment sets the "comment" field.
func (m *IdentityLinkMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *IdentityLinkMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *IdentityLinkMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[identitylink.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *IdentityLinkMutation) CommentCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *IdentityLinkMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, identitylink.FieldComment)
}

// SetTaskID sets the "task_id" field.
func (m *IdentityLinkMutation) SetTaskID(i int64) {
	m.task_id = &i
	m.addtask_id = nil
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *IdentityLinkMutation) TaskID() (r int64, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldTaskID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// AddTaskID adds i to the "task_id" field.
func (m *IdentityLinkMutation) AddTaskID(i int64) {
	if m.addtask_id != nil {
		*m.addtask_id += i
	} else {
		m.addtask_id = &i
	}
}

// AddedTaskID returns the value that was added to the "task_id" field in this mutation.
func (m *IdentityLinkMutation) AddedTaskID() (r int64, exists bool) {
	v := m.addtask_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *IdentityLinkMutation) ResetTaskID() {
	m.task_id = nil
	m.addtask_id = nil
}

// SetResult sets the "result" field.
func (m *IdentityLinkMutation) SetResult(i int) {
	m.result = &i
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *IdentityLinkMutation) Result() (r int, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldResult(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds i to the "result" field.
func (m *IdentityLinkMutation) AddResult(i int) {
	if m.addresult != nil {
		*m.addresult += i
	} else {
		m.addresult = &i
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *IdentityLinkMutation) AddedResult() (r int, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ClearResult clears the value of the "result" field.
func (m *IdentityLinkMutation) ClearResult() {
	m.result = nil
	m.addresult = nil
	m.clearedFields[identitylink.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *IdentityLinkMutation) ResultCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *IdentityLinkMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
	delete(m.clearedFields, identitylink.FieldResult)
}

// SetCreateTime sets the "create_time" field.
func (m *IdentityLinkMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *IdentityLinkMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *IdentityLinkMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[identitylink.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *IdentityLinkMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *IdentityLinkMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, identitylink.FieldCreateTime)
}

// SetIsDel sets the "is_del" field.
func (m *IdentityLinkMutation) SetIsDel(i int8) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *IdentityLinkMutation) IsDel() (r int8, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldIsDel(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *IdentityLinkMutation) AddIsDel(i int8) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *IdentityLinkMutation) AddedIsDel() (r int8, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsDel clears the value of the "is_del" field.
func (m *IdentityLinkMutation) ClearIsDel() {
	m.is_del = nil
	m.addis_del = nil
	m.clearedFields[identitylink.FieldIsDel] = struct{}{}
}

// IsDelCleared returns if the "is_del" field was cleared in this mutation.
func (m *IdentityLinkMutation) IsDelCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldIsDel]
	return ok
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *IdentityLinkMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
	delete(m.clearedFields, identitylink.FieldIsDel)
}

// SetIsDeal sets the "is_deal" field.
func (m *IdentityLinkMutation) SetIsDeal(i int8) {
	m.is_deal = &i
	m.addis_deal = nil
}

// IsDeal returns the value of the "is_deal" field in the mutation.
func (m *IdentityLinkMutation) IsDeal() (r int8, exists bool) {
	v := m.is_deal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeal returns the old "is_deal" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldIsDeal(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeal: %w", err)
	}
	return oldValue.IsDeal, nil
}

// AddIsDeal adds i to the "is_deal" field.
func (m *IdentityLinkMutation) AddIsDeal(i int8) {
	if m.addis_deal != nil {
		*m.addis_deal += i
	} else {
		m.addis_deal = &i
	}
}

// AddedIsDeal returns the value that was added to the "is_deal" field in this mutation.
func (m *IdentityLinkMutation) AddedIsDeal() (r int8, exists bool) {
	v := m.addis_deal
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsDeal clears the value of the "is_deal" field.
func (m *IdentityLinkMutation) ClearIsDeal() {
	m.is_deal = nil
	m.addis_deal = nil
	m.clearedFields[identitylink.FieldIsDeal] = struct{}{}
}

// IsDealCleared returns if the "is_deal" field was cleared in this mutation.
func (m *IdentityLinkMutation) IsDealCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldIsDeal]
	return ok
}

// ResetIsDeal resets all changes to the "is_deal" field.
func (m *IdentityLinkMutation) ResetIsDeal() {
	m.is_deal = nil
	m.addis_deal = nil
	delete(m.clearedFields, identitylink.FieldIsDeal)
}

// SetUpdateTime sets the "update_time" field.
func (m *IdentityLinkMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *IdentityLinkMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *IdentityLinkMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[identitylink.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *IdentityLinkMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *IdentityLinkMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, identitylink.FieldUpdateTime)
}

// Where appends a list predicates to the IdentityLinkMutation builder.
func (m *IdentityLinkMutation) Where(ps ...predicate.IdentityLink) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IdentityLinkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (IdentityLink).
func (m *IdentityLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentityLinkMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user_id != nil {
		fields = append(fields, identitylink.FieldUserID)
	}
	if m.user_name != nil {
		fields = append(fields, identitylink.FieldUserName)
	}
	if m.step != nil {
		fields = append(fields, identitylink.FieldStep)
	}
	if m.proc_inst_id != nil {
		fields = append(fields, identitylink.FieldProcInstID)
	}
	if m.target_id != nil {
		fields = append(fields, identitylink.FieldTargetID)
	}
	if m.comment != nil {
		fields = append(fields, identitylink.FieldComment)
	}
	if m.task_id != nil {
		fields = append(fields, identitylink.FieldTaskID)
	}
	if m.result != nil {
		fields = append(fields, identitylink.FieldResult)
	}
	if m.create_time != nil {
		fields = append(fields, identitylink.FieldCreateTime)
	}
	if m.is_del != nil {
		fields = append(fields, identitylink.FieldIsDel)
	}
	if m.is_deal != nil {
		fields = append(fields, identitylink.FieldIsDeal)
	}
	if m.update_time != nil {
		fields = append(fields, identitylink.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentityLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identitylink.FieldUserID:
		return m.UserID()
	case identitylink.FieldUserName:
		return m.UserName()
	case identitylink.FieldStep:
		return m.Step()
	case identitylink.FieldProcInstID:
		return m.ProcInstID()
	case identitylink.FieldTargetID:
		return m.TargetID()
	case identitylink.FieldComment:
		return m.Comment()
	case identitylink.FieldTaskID:
		return m.TaskID()
	case identitylink.FieldResult:
		return m.Result()
	case identitylink.FieldCreateTime:
		return m.CreateTime()
	case identitylink.FieldIsDel:
		return m.IsDel()
	case identitylink.FieldIsDeal:
		return m.IsDeal()
	case identitylink.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentityLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identitylink.FieldUserID:
		return m.OldUserID(ctx)
	case identitylink.FieldUserName:
		return m.OldUserName(ctx)
	case identitylink.FieldStep:
		return m.OldStep(ctx)
	case identitylink.FieldProcInstID:
		return m.OldProcInstID(ctx)
	case identitylink.FieldTargetID:
		return m.OldTargetID(ctx)
	case identitylink.FieldComment:
		return m.OldComment(ctx)
	case identitylink.FieldTaskID:
		return m.OldTaskID(ctx)
	case identitylink.FieldResult:
		return m.OldResult(ctx)
	case identitylink.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case identitylink.FieldIsDel:
		return m.OldIsDel(ctx)
	case identitylink.FieldIsDeal:
		return m.OldIsDeal(ctx)
	case identitylink.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown IdentityLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identitylink.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case identitylink.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case identitylink.FieldStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStep(v)
		return nil
	case identitylink.FieldProcInstID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcInstID(v)
		return nil
	case identitylink.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case identitylink.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case identitylink.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case identitylink.FieldResult:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case identitylink.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case identitylink.FieldIsDel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case identitylink.FieldIsDeal:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeal(v)
		return nil
	case identitylink.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown IdentityLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentityLinkMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, identitylink.FieldUserID)
	}
	if m.addstep != nil {
		fields = append(fields, identitylink.FieldStep)
	}
	if m.addproc_inst_id != nil {
		fields = append(fields, identitylink.FieldProcInstID)
	}
	if m.addtarget_id != nil {
		fields = append(fields, identitylink.FieldTargetID)
	}
	if m.addtask_id != nil {
		fields = append(fields, identitylink.FieldTaskID)
	}
	if m.addresult != nil {
		fields = append(fields, identitylink.FieldResult)
	}
	if m.addis_del != nil {
		fields = append(fields, identitylink.FieldIsDel)
	}
	if m.addis_deal != nil {
		fields = append(fields, identitylink.FieldIsDeal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentityLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case identitylink.FieldUserID:
		return m.AddedUserID()
	case identitylink.FieldStep:
		return m.AddedStep()
	case identitylink.FieldProcInstID:
		return m.AddedProcInstID()
	case identitylink.FieldTargetID:
		return m.AddedTargetID()
	case identitylink.FieldTaskID:
		return m.AddedTaskID()
	case identitylink.FieldResult:
		return m.AddedResult()
	case identitylink.FieldIsDel:
		return m.AddedIsDel()
	case identitylink.FieldIsDeal:
		return m.AddedIsDeal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case identitylink.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case identitylink.FieldStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStep(v)
		return nil
	case identitylink.FieldProcInstID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcInstID(v)
		return nil
	case identitylink.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetID(v)
		return nil
	case identitylink.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskID(v)
		return nil
	case identitylink.FieldResult:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case identitylink.FieldIsDel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	case identitylink.FieldIsDeal:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeal(v)
		return nil
	}
	return fmt.Errorf("unknown IdentityLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentityLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(identitylink.FieldUserID) {
		fields = append(fields, identitylink.FieldUserID)
	}
	if m.FieldCleared(identitylink.FieldUserName) {
		fields = append(fields, identitylink.FieldUserName)
	}
	if m.FieldCleared(identitylink.FieldStep) {
		fields = append(fields, identitylink.FieldStep)
	}
	if m.FieldCleared(identitylink.FieldTargetID) {
		fields = append(fields, identitylink.FieldTargetID)
	}
	if m.FieldCleared(identitylink.FieldComment) {
		fields = append(fields, identitylink.FieldComment)
	}
	if m.FieldCleared(identitylink.FieldResult) {
		fields = append(fields, identitylink.FieldResult)
	}
	if m.FieldCleared(identitylink.FieldCreateTime) {
		fields = append(fields, identitylink.FieldCreateTime)
	}
	if m.FieldCleared(identitylink.FieldIsDel) {
		fields = append(fields, identitylink.FieldIsDel)
	}
	if m.FieldCleared(identitylink.FieldIsDeal) {
		fields = append(fields, identitylink.FieldIsDeal)
	}
	if m.FieldCleared(identitylink.FieldUpdateTime) {
		fields = append(fields, identitylink.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentityLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentityLinkMutation) ClearField(name string) error {
	switch name {
	case identitylink.FieldUserID:
		m.ClearUserID()
		return nil
	case identitylink.FieldUserName:
		m.ClearUserName()
		return nil
	case identitylink.FieldStep:
		m.ClearStep()
		return nil
	case identitylink.FieldTargetID:
		m.ClearTargetID()
		return nil
	case identitylink.FieldComment:
		m.ClearComment()
		return nil
	case identitylink.FieldResult:
		m.ClearResult()
		return nil
	case identitylink.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case identitylink.FieldIsDel:
		m.ClearIsDel()
		return nil
	case identitylink.FieldIsDeal:
		m.ClearIsDeal()
		return nil
	case identitylink.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown IdentityLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentityLinkMutation) ResetField(name string) error {
	switch name {
	case identitylink.FieldUserID:
		m.ResetUserID()
		return nil
	case identitylink.FieldUserName:
		m.ResetUserName()
		return nil
	case identitylink.FieldStep:
		m.ResetStep()
		return nil
	case identitylink.FieldProcInstID:
		m.ResetProcInstID()
		return nil
	case identitylink.FieldTargetID:
		m.ResetTargetID()
		return nil
	case identitylink.FieldComment:
		m.ResetComment()
		return nil
	case identitylink.FieldTaskID:
		m.ResetTaskID()
		return nil
	case identitylink.FieldResult:
		m.ResetResult()
		return nil
	case identitylink.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case identitylink.FieldIsDel:
		m.ResetIsDel()
		return nil
	case identitylink.FieldIsDeal:
		m.ResetIsDeal()
		return nil
	case identitylink.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown IdentityLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentityLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentityLinkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentityLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentityLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentityLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentityLinkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentityLinkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IdentityLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentityLinkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IdentityLink edge %s", name)
}

// ProcDefMutation represents an operation that mutates the ProcDef nodes in the graph.
type ProcDefMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name              *string
	code              *string
	version           *int
	addversion        *int
	resource          *string
	create_user_id    *int64
	addcreate_user_id *int64
	create_user_name  *string
	create_time       *time.Time
	target_id         *int64
	addtarget_id      *int64
	form_id           *string
	form_name         *string
	remain_hours      *int
	addremain_hours   *int
	is_del            *int8
	addis_del         *int8
	is_active         *int8
	addis_active      *int8
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ProcDef, error)
	predicates        []predicate.ProcDef
}

var _ ent.Mutation = (*ProcDefMutation)(nil)

// procdefOption allows management of the mutation configuration using functional options.
type procdefOption func(*ProcDefMutation)

// newProcDefMutation creates new mutation for the ProcDef entity.
func newProcDefMutation(c config, op Op, opts ...procdefOption) *ProcDefMutation {
	m := &ProcDefMutation{
		config:        c,
		op:            op,
		typ:           TypeProcDef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcDefID sets the ID field of the mutation.
func withProcDefID(id int64) procdefOption {
	return func(m *ProcDefMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcDef
		)
		m.oldValue = func(ctx context.Context) (*ProcDef, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcDef.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcDef sets the old ProcDef of the mutation.
func withProcDef(node *ProcDef) procdefOption {
	return func(m *ProcDefMutation) {
		m.oldValue = func(context.Context) (*ProcDef, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcDefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcDefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("act: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcDefMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcDefMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcDef.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProcDefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcDefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProcDefMutation) ClearName() {
	m.name = nil
	m.clearedFields[procdef.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProcDefMutation) NameCleared() bool {
	_, ok := m.clearedFields[procdef.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProcDefMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, procdef.FieldName)
}

// SetCode sets the "code" field.
func (m *ProcDefMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ProcDefMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *ProcDefMutation) ClearCode() {
	m.code = nil
	m.clearedFields[procdef.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *ProcDefMutation) CodeCleared() bool {
	_, ok := m.clearedFields[procdef.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *ProcDefMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, procdef.FieldCode)
}

// SetVersion sets the "version" field.
func (m *ProcDefMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ProcDefMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ProcDefMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ProcDefMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersion clears the value of the "version" field.
func (m *ProcDefMutation) ClearVersion() {
	m.version = nil
	m.addversion = nil
	m.clearedFields[procdef.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ProcDefMutation) VersionCleared() bool {
	_, ok := m.clearedFields[procdef.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ProcDefMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
	delete(m.clearedFields, procdef.FieldVersion)
}

// SetResource sets the "resource" field.
func (m *ProcDefMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *ProcDefMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ClearResource clears the value of the "resource" field.
func (m *ProcDefMutation) ClearResource() {
	m.resource = nil
	m.clearedFields[procdef.FieldResource] = struct{}{}
}

// ResourceCleared returns if the "resource" field was cleared in this mutation.
func (m *ProcDefMutation) ResourceCleared() bool {
	_, ok := m.clearedFields[procdef.FieldResource]
	return ok
}

// ResetResource resets all changes to the "resource" field.
func (m *ProcDefMutation) ResetResource() {
	m.resource = nil
	delete(m.clearedFields, procdef.FieldResource)
}

// SetCreateUserID sets the "create_user_id" field.
func (m *ProcDefMutation) SetCreateUserID(i int64) {
	m.create_user_id = &i
	m.addcreate_user_id = nil
}

// CreateUserID returns the value of the "create_user_id" field in the mutation.
func (m *ProcDefMutation) CreateUserID() (r int64, exists bool) {
	v := m.create_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUserID returns the old "create_user_id" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldCreateUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUserID: %w", err)
	}
	return oldValue.CreateUserID, nil
}

// AddCreateUserID adds i to the "create_user_id" field.
func (m *ProcDefMutation) AddCreateUserID(i int64) {
	if m.addcreate_user_id != nil {
		*m.addcreate_user_id += i
	} else {
		m.addcreate_user_id = &i
	}
}

// AddedCreateUserID returns the value that was added to the "create_user_id" field in this mutation.
func (m *ProcDefMutation) AddedCreateUserID() (r int64, exists bool) {
	v := m.addcreate_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUserID clears the value of the "create_user_id" field.
func (m *ProcDefMutation) ClearCreateUserID() {
	m.create_user_id = nil
	m.addcreate_user_id = nil
	m.clearedFields[procdef.FieldCreateUserID] = struct{}{}
}

// CreateUserIDCleared returns if the "create_user_id" field was cleared in this mutation.
func (m *ProcDefMutation) CreateUserIDCleared() bool {
	_, ok := m.clearedFields[procdef.FieldCreateUserID]
	return ok
}

// ResetCreateUserID resets all changes to the "create_user_id" field.
func (m *ProcDefMutation) ResetCreateUserID() {
	m.create_user_id = nil
	m.addcreate_user_id = nil
	delete(m.clearedFields, procdef.FieldCreateUserID)
}

// SetCreateUserName sets the "create_user_name" field.
func (m *ProcDefMutation) SetCreateUserName(s string) {
	m.create_user_name = &s
}

// CreateUserName returns the value of the "create_user_name" field in the mutation.
func (m *ProcDefMutation) CreateUserName() (r string, exists bool) {
	v := m.create_user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUserName returns the old "create_user_name" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldCreateUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUserName: %w", err)
	}
	return oldValue.CreateUserName, nil
}

// ClearCreateUserName clears the value of the "create_user_name" field.
func (m *ProcDefMutation) ClearCreateUserName() {
	m.create_user_name = nil
	m.clearedFields[procdef.FieldCreateUserName] = struct{}{}
}

// CreateUserNameCleared returns if the "create_user_name" field was cleared in this mutation.
func (m *ProcDefMutation) CreateUserNameCleared() bool {
	_, ok := m.clearedFields[procdef.FieldCreateUserName]
	return ok
}

// ResetCreateUserName resets all changes to the "create_user_name" field.
func (m *ProcDefMutation) ResetCreateUserName() {
	m.create_user_name = nil
	delete(m.clearedFields, procdef.FieldCreateUserName)
}

// SetCreateTime sets the "create_time" field.
func (m *ProcDefMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProcDefMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ProcDefMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[procdef.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ProcDefMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[procdef.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProcDefMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, procdef.FieldCreateTime)
}

// SetTargetID sets the "target_id" field.
func (m *ProcDefMutation) SetTargetID(i int64) {
	m.target_id = &i
	m.addtarget_id = nil
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *ProcDefMutation) TargetID() (r int64, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldTargetID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// AddTargetID adds i to the "target_id" field.
func (m *ProcDefMutation) AddTargetID(i int64) {
	if m.addtarget_id != nil {
		*m.addtarget_id += i
	} else {
		m.addtarget_id = &i
	}
}

// AddedTargetID returns the value that was added to the "target_id" field in this mutation.
func (m *ProcDefMutation) AddedTargetID() (r int64, exists bool) {
	v := m.addtarget_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetID clears the value of the "target_id" field.
func (m *ProcDefMutation) ClearTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	m.clearedFields[procdef.FieldTargetID] = struct{}{}
}

// TargetIDCleared returns if the "target_id" field was cleared in this mutation.
func (m *ProcDefMutation) TargetIDCleared() bool {
	_, ok := m.clearedFields[procdef.FieldTargetID]
	return ok
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *ProcDefMutation) ResetTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	delete(m.clearedFields, procdef.FieldTargetID)
}

// SetFormID sets the "form_id" field.
func (m *ProcDefMutation) SetFormID(s string) {
	m.form_id = &s
}

// FormID returns the value of the "form_id" field in the mutation.
func (m *ProcDefMutation) FormID() (r string, exists bool) {
	v := m.form_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFormID returns the old "form_id" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldFormID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormID: %w", err)
	}
	return oldValue.FormID, nil
}

// ClearFormID clears the value of the "form_id" field.
func (m *ProcDefMutation) ClearFormID() {
	m.form_id = nil
	m.clearedFields[procdef.FieldFormID] = struct{}{}
}

// FormIDCleared returns if the "form_id" field was cleared in this mutation.
func (m *ProcDefMutation) FormIDCleared() bool {
	_, ok := m.clearedFields[procdef.FieldFormID]
	return ok
}

// ResetFormID resets all changes to the "form_id" field.
func (m *ProcDefMutation) ResetFormID() {
	m.form_id = nil
	delete(m.clearedFields, procdef.FieldFormID)
}

// SetFormName sets the "form_name" field.
func (m *ProcDefMutation) SetFormName(s string) {
	m.form_name = &s
}

// FormName returns the value of the "form_name" field in the mutation.
func (m *ProcDefMutation) FormName() (r string, exists bool) {
	v := m.form_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFormName returns the old "form_name" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldFormName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormName: %w", err)
	}
	return oldValue.FormName, nil
}

// ClearFormName clears the value of the "form_name" field.
func (m *ProcDefMutation) ClearFormName() {
	m.form_name = nil
	m.clearedFields[procdef.FieldFormName] = struct{}{}
}

// FormNameCleared returns if the "form_name" field was cleared in this mutation.
func (m *ProcDefMutation) FormNameCleared() bool {
	_, ok := m.clearedFields[procdef.FieldFormName]
	return ok
}

// ResetFormName resets all changes to the "form_name" field.
func (m *ProcDefMutation) ResetFormName() {
	m.form_name = nil
	delete(m.clearedFields, procdef.FieldFormName)
}

// SetRemainHours sets the "remain_hours" field.
func (m *ProcDefMutation) SetRemainHours(i int) {
	m.remain_hours = &i
	m.addremain_hours = nil
}

// RemainHours returns the value of the "remain_hours" field in the mutation.
func (m *ProcDefMutation) RemainHours() (r int, exists bool) {
	v := m.remain_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainHours returns the old "remain_hours" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldRemainHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainHours: %w", err)
	}
	return oldValue.RemainHours, nil
}

// AddRemainHours adds i to the "remain_hours" field.
func (m *ProcDefMutation) AddRemainHours(i int) {
	if m.addremain_hours != nil {
		*m.addremain_hours += i
	} else {
		m.addremain_hours = &i
	}
}

// AddedRemainHours returns the value that was added to the "remain_hours" field in this mutation.
func (m *ProcDefMutation) AddedRemainHours() (r int, exists bool) {
	v := m.addremain_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemainHours clears the value of the "remain_hours" field.
func (m *ProcDefMutation) ClearRemainHours() {
	m.remain_hours = nil
	m.addremain_hours = nil
	m.clearedFields[procdef.FieldRemainHours] = struct{}{}
}

// RemainHoursCleared returns if the "remain_hours" field was cleared in this mutation.
func (m *ProcDefMutation) RemainHoursCleared() bool {
	_, ok := m.clearedFields[procdef.FieldRemainHours]
	return ok
}

// ResetRemainHours resets all changes to the "remain_hours" field.
func (m *ProcDefMutation) ResetRemainHours() {
	m.remain_hours = nil
	m.addremain_hours = nil
	delete(m.clearedFields, procdef.FieldRemainHours)
}

// SetIsDel sets the "is_del" field.
func (m *ProcDefMutation) SetIsDel(i int8) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *ProcDefMutation) IsDel() (r int8, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldIsDel(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *ProcDefMutation) AddIsDel(i int8) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *ProcDefMutation) AddedIsDel() (r int8, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsDel clears the value of the "is_del" field.
func (m *ProcDefMutation) ClearIsDel() {
	m.is_del = nil
	m.addis_del = nil
	m.clearedFields[procdef.FieldIsDel] = struct{}{}
}

// IsDelCleared returns if the "is_del" field was cleared in this mutation.
func (m *ProcDefMutation) IsDelCleared() bool {
	_, ok := m.clearedFields[procdef.FieldIsDel]
	return ok
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *ProcDefMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
	delete(m.clearedFields, procdef.FieldIsDel)
}

// SetIsActive sets the "is_active" field.
func (m *ProcDefMutation) SetIsActive(i int8) {
	m.is_active = &i
	m.addis_active = nil
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ProcDefMutation) IsActive() (r int8, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldIsActive(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// AddIsActive adds i to the "is_active" field.
func (m *ProcDefMutation) AddIsActive(i int8) {
	if m.addis_active != nil {
		*m.addis_active += i
	} else {
		m.addis_active = &i
	}
}

// AddedIsActive returns the value that was added to the "is_active" field in this mutation.
func (m *ProcDefMutation) AddedIsActive() (r int8, exists bool) {
	v := m.addis_active
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsActive clears the value of the "is_active" field.
func (m *ProcDefMutation) ClearIsActive() {
	m.is_active = nil
	m.addis_active = nil
	m.clearedFields[procdef.FieldIsActive] = struct{}{}
}

// IsActiveCleared returns if the "is_active" field was cleared in this mutation.
func (m *ProcDefMutation) IsActiveCleared() bool {
	_, ok := m.clearedFields[procdef.FieldIsActive]
	return ok
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ProcDefMutation) ResetIsActive() {
	m.is_active = nil
	m.addis_active = nil
	delete(m.clearedFields, procdef.FieldIsActive)
}

// SetUpdateTime sets the "update_time" field.
func (m *ProcDefMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProcDefMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *ProcDefMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[procdef.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *ProcDefMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[procdef.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProcDefMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, procdef.FieldUpdateTime)
}

// Where appends a list predicates to the ProcDefMutation builder.
func (m *ProcDefMutation) Where(ps ...predicate.ProcDef) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProcDefMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProcDef).
func (m *ProcDefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcDefMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, procdef.FieldName)
	}
	if m.code != nil {
		fields = append(fields, procdef.FieldCode)
	}
	if m.version != nil {
		fields = append(fields, procdef.FieldVersion)
	}
	if m.resource != nil {
		fields = append(fields, procdef.FieldResource)
	}
	if m.create_user_id != nil {
		fields = append(fields, procdef.FieldCreateUserID)
	}
	if m.create_user_name != nil {
		fields = append(fields, procdef.FieldCreateUserName)
	}
	if m.create_time != nil {
		fields = append(fields, procdef.FieldCreateTime)
	}
	if m.target_id != nil {
		fields = append(fields, procdef.FieldTargetID)
	}
	if m.form_id != nil {
		fields = append(fields, procdef.FieldFormID)
	}
	if m.form_name != nil {
		fields = append(fields, procdef.FieldFormName)
	}
	if m.remain_hours != nil {
		fields = append(fields, procdef.FieldRemainHours)
	}
	if m.is_del != nil {
		fields = append(fields, procdef.FieldIsDel)
	}
	if m.is_active != nil {
		fields = append(fields, procdef.FieldIsActive)
	}
	if m.update_time != nil {
		fields = append(fields, procdef.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcDefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case procdef.FieldName:
		return m.Name()
	case procdef.FieldCode:
		return m.Code()
	case procdef.FieldVersion:
		return m.Version()
	case procdef.FieldResource:
		return m.Resource()
	case procdef.FieldCreateUserID:
		return m.CreateUserID()
	case procdef.FieldCreateUserName:
		return m.CreateUserName()
	case procdef.FieldCreateTime:
		return m.CreateTime()
	case procdef.FieldTargetID:
		return m.TargetID()
	case procdef.FieldFormID:
		return m.FormID()
	case procdef.FieldFormName:
		return m.FormName()
	case procdef.FieldRemainHours:
		return m.RemainHours()
	case procdef.FieldIsDel:
		return m.IsDel()
	case procdef.FieldIsActive:
		return m.IsActive()
	case procdef.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcDefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case procdef.FieldName:
		return m.OldName(ctx)
	case procdef.FieldCode:
		return m.OldCode(ctx)
	case procdef.FieldVersion:
		return m.OldVersion(ctx)
	case procdef.FieldResource:
		return m.OldResource(ctx)
	case procdef.FieldCreateUserID:
		return m.OldCreateUserID(ctx)
	case procdef.FieldCreateUserName:
		return m.OldCreateUserName(ctx)
	case procdef.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case procdef.FieldTargetID:
		return m.OldTargetID(ctx)
	case procdef.FieldFormID:
		return m.OldFormID(ctx)
	case procdef.FieldFormName:
		return m.OldFormName(ctx)
	case procdef.FieldRemainHours:
		return m.OldRemainHours(ctx)
	case procdef.FieldIsDel:
		return m.OldIsDel(ctx)
	case procdef.FieldIsActive:
		return m.OldIsActive(ctx)
	case procdef.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ProcDef field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcDefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case procdef.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case procdef.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case procdef.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case procdef.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case procdef.FieldCreateUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUserID(v)
		return nil
	case procdef.FieldCreateUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUserName(v)
		return nil
	case procdef.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case procdef.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case procdef.FieldFormID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormID(v)
		return nil
	case procdef.FieldFormName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormName(v)
		return nil
	case procdef.FieldRemainHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainHours(v)
		return nil
	case procdef.FieldIsDel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case procdef.FieldIsActive:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case procdef.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProcDef field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcDefMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, procdef.FieldVersion)
	}
	if m.addcreate_user_id != nil {
		fields = append(fields, procdef.FieldCreateUserID)
	}
	if m.addtarget_id != nil {
		fields = append(fields, procdef.FieldTargetID)
	}
	if m.addremain_hours != nil {
		fields = append(fields, procdef.FieldRemainHours)
	}
	if m.addis_del != nil {
		fields = append(fields, procdef.FieldIsDel)
	}
	if m.addis_active != nil {
		fields = append(fields, procdef.FieldIsActive)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcDefMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case procdef.FieldVersion:
		return m.AddedVersion()
	case procdef.FieldCreateUserID:
		return m.AddedCreateUserID()
	case procdef.FieldTargetID:
		return m.AddedTargetID()
	case procdef.FieldRemainHours:
		return m.AddedRemainHours()
	case procdef.FieldIsDel:
		return m.AddedIsDel()
	case procdef.FieldIsActive:
		return m.AddedIsActive()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcDefMutation) AddField(name string, value ent.Value) error {
	switch name {
	case procdef.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case procdef.FieldCreateUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUserID(v)
		return nil
	case procdef.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetID(v)
		return nil
	case procdef.FieldRemainHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainHours(v)
		return nil
	case procdef.FieldIsDel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	case procdef.FieldIsActive:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown ProcDef numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcDefMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(procdef.FieldName) {
		fields = append(fields, procdef.FieldName)
	}
	if m.FieldCleared(procdef.FieldCode) {
		fields = append(fields, procdef.FieldCode)
	}
	if m.FieldCleared(procdef.FieldVersion) {
		fields = append(fields, procdef.FieldVersion)
	}
	if m.FieldCleared(procdef.FieldResource) {
		fields = append(fields, procdef.FieldResource)
	}
	if m.FieldCleared(procdef.FieldCreateUserID) {
		fields = append(fields, procdef.FieldCreateUserID)
	}
	if m.FieldCleared(procdef.FieldCreateUserName) {
		fields = append(fields, procdef.FieldCreateUserName)
	}
	if m.FieldCleared(procdef.FieldCreateTime) {
		fields = append(fields, procdef.FieldCreateTime)
	}
	if m.FieldCleared(procdef.FieldTargetID) {
		fields = append(fields, procdef.FieldTargetID)
	}
	if m.FieldCleared(procdef.FieldFormID) {
		fields = append(fields, procdef.FieldFormID)
	}
	if m.FieldCleared(procdef.FieldFormName) {
		fields = append(fields, procdef.FieldFormName)
	}
	if m.FieldCleared(procdef.FieldRemainHours) {
		fields = append(fields, procdef.FieldRemainHours)
	}
	if m.FieldCleared(procdef.FieldIsDel) {
		fields = append(fields, procdef.FieldIsDel)
	}
	if m.FieldCleared(procdef.FieldIsActive) {
		fields = append(fields, procdef.FieldIsActive)
	}
	if m.FieldCleared(procdef.FieldUpdateTime) {
		fields = append(fields, procdef.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcDefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcDefMutation) ClearField(name string) error {
	switch name {
	case procdef.FieldName:
		m.ClearName()
		return nil
	case procdef.FieldCode:
		m.ClearCode()
		return nil
	case procdef.FieldVersion:
		m.ClearVersion()
		return nil
	case procdef.FieldResource:
		m.ClearResource()
		return nil
	case procdef.FieldCreateUserID:
		m.ClearCreateUserID()
		return nil
	case procdef.FieldCreateUserName:
		m.ClearCreateUserName()
		return nil
	case procdef.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case procdef.FieldTargetID:
		m.ClearTargetID()
		return nil
	case procdef.FieldFormID:
		m.ClearFormID()
		return nil
	case procdef.FieldFormName:
		m.ClearFormName()
		return nil
	case procdef.FieldRemainHours:
		m.ClearRemainHours()
		return nil
	case procdef.FieldIsDel:
		m.ClearIsDel()
		return nil
	case procdef.FieldIsActive:
		m.ClearIsActive()
		return nil
	case procdef.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ProcDef nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcDefMutation) ResetField(name string) error {
	switch name {
	case procdef.FieldName:
		m.ResetName()
		return nil
	case procdef.FieldCode:
		m.ResetCode()
		return nil
	case procdef.FieldVersion:
		m.ResetVersion()
		return nil
	case procdef.FieldResource:
		m.ResetResource()
		return nil
	case procdef.FieldCreateUserID:
		m.ResetCreateUserID()
		return nil
	case procdef.FieldCreateUserName:
		m.ResetCreateUserName()
		return nil
	case procdef.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case procdef.FieldTargetID:
		m.ResetTargetID()
		return nil
	case procdef.FieldFormID:
		m.ResetFormID()
		return nil
	case procdef.FieldFormName:
		m.ResetFormName()
		return nil
	case procdef.FieldRemainHours:
		m.ResetRemainHours()
		return nil
	case procdef.FieldIsDel:
		m.ResetIsDel()
		return nil
	case procdef.FieldIsActive:
		m.ResetIsActive()
		return nil
	case procdef.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ProcDef field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcDefMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcDefMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcDefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcDefMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcDefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcDefMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcDefMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcDef unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcDefMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcDef edge %s", name)
}

// ProcInstMutation represents an operation that mutates the ProcInst nodes in the graph.
type ProcInstMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	proc_def_id      *int64
	addproc_def_id   *int64
	title            *string
	code             *string
	target_id        *int64
	addtarget_id     *int64
	node_id          *string
	task_id          *int64
	addtask_id       *int64
	start_time       *time.Time
	end_time         *time.Time
	start_user_id    *int64
	addstart_user_id *int64
	start_user_name  *string
	is_finished      *int8
	addis_finished   *int8
	state            *int
	addstate         *int
	data_id          *int64
	adddata_id       *int64
	is_del           *int
	addis_del        *int
	create_time      *time.Time
	remain_hours     *int
	addremain_hours  *int
	update_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ProcInst, error)
	predicates       []predicate.ProcInst
}

var _ ent.Mutation = (*ProcInstMutation)(nil)

// procinstOption allows management of the mutation configuration using functional options.
type procinstOption func(*ProcInstMutation)

// newProcInstMutation creates new mutation for the ProcInst entity.
func newProcInstMutation(c config, op Op, opts ...procinstOption) *ProcInstMutation {
	m := &ProcInstMutation{
		config:        c,
		op:            op,
		typ:           TypeProcInst,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcInstID sets the ID field of the mutation.
func withProcInstID(id int64) procinstOption {
	return func(m *ProcInstMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcInst
		)
		m.oldValue = func(ctx context.Context) (*ProcInst, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcInst.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcInst sets the old ProcInst of the mutation.
func withProcInst(node *ProcInst) procinstOption {
	return func(m *ProcInstMutation) {
		m.oldValue = func(context.Context) (*ProcInst, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcInstMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcInstMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("act: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcInstMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcInstMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcInst.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProcDefID sets the "proc_def_id" field.
func (m *ProcInstMutation) SetProcDefID(i int64) {
	m.proc_def_id = &i
	m.addproc_def_id = nil
}

// ProcDefID returns the value of the "proc_def_id" field in the mutation.
func (m *ProcInstMutation) ProcDefID() (r int64, exists bool) {
	v := m.proc_def_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcDefID returns the old "proc_def_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldProcDefID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcDefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcDefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcDefID: %w", err)
	}
	return oldValue.ProcDefID, nil
}

// AddProcDefID adds i to the "proc_def_id" field.
func (m *ProcInstMutation) AddProcDefID(i int64) {
	if m.addproc_def_id != nil {
		*m.addproc_def_id += i
	} else {
		m.addproc_def_id = &i
	}
}

// AddedProcDefID returns the value that was added to the "proc_def_id" field in this mutation.
func (m *ProcInstMutation) AddedProcDefID() (r int64, exists bool) {
	v := m.addproc_def_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcDefID resets all changes to the "proc_def_id" field.
func (m *ProcInstMutation) ResetProcDefID() {
	m.proc_def_id = nil
	m.addproc_def_id = nil
}

// SetTitle sets the "title" field.
func (m *ProcInstMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProcInstMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ProcInstMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[procinst.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ProcInstMutation) TitleCleared() bool {
	_, ok := m.clearedFields[procinst.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ProcInstMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, procinst.FieldTitle)
}

// SetCode sets the "code" field.
func (m *ProcInstMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ProcInstMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *ProcInstMutation) ClearCode() {
	m.code = nil
	m.clearedFields[procinst.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *ProcInstMutation) CodeCleared() bool {
	_, ok := m.clearedFields[procinst.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *ProcInstMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, procinst.FieldCode)
}

// SetTargetID sets the "target_id" field.
func (m *ProcInstMutation) SetTargetID(i int64) {
	m.target_id = &i
	m.addtarget_id = nil
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *ProcInstMutation) TargetID() (r int64, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldTargetID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// AddTargetID adds i to the "target_id" field.
func (m *ProcInstMutation) AddTargetID(i int64) {
	if m.addtarget_id != nil {
		*m.addtarget_id += i
	} else {
		m.addtarget_id = &i
	}
}

// AddedTargetID returns the value that was added to the "target_id" field in this mutation.
func (m *ProcInstMutation) AddedTargetID() (r int64, exists bool) {
	v := m.addtarget_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetID clears the value of the "target_id" field.
func (m *ProcInstMutation) ClearTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	m.clearedFields[procinst.FieldTargetID] = struct{}{}
}

// TargetIDCleared returns if the "target_id" field was cleared in this mutation.
func (m *ProcInstMutation) TargetIDCleared() bool {
	_, ok := m.clearedFields[procinst.FieldTargetID]
	return ok
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *ProcInstMutation) ResetTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	delete(m.clearedFields, procinst.FieldTargetID)
}

// SetNodeID sets the "node_id" field.
func (m *ProcInstMutation) SetNodeID(s string) {
	m.node_id = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *ProcInstMutation) NodeID() (r string, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ClearNodeID clears the value of the "node_id" field.
func (m *ProcInstMutation) ClearNodeID() {
	m.node_id = nil
	m.clearedFields[procinst.FieldNodeID] = struct{}{}
}

// NodeIDCleared returns if the "node_id" field was cleared in this mutation.
func (m *ProcInstMutation) NodeIDCleared() bool {
	_, ok := m.clearedFields[procinst.FieldNodeID]
	return ok
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *ProcInstMutation) ResetNodeID() {
	m.node_id = nil
	delete(m.clearedFields, procinst.FieldNodeID)
}

// SetTaskID sets the "task_id" field.
func (m *ProcInstMutation) SetTaskID(i int64) {
	m.task_id = &i
	m.addtask_id = nil
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ProcInstMutation) TaskID() (r int64, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldTaskID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// AddTaskID adds i to the "task_id" field.
func (m *ProcInstMutation) AddTaskID(i int64) {
	if m.addtask_id != nil {
		*m.addtask_id += i
	} else {
		m.addtask_id = &i
	}
}

// AddedTaskID returns the value that was added to the "task_id" field in this mutation.
func (m *ProcInstMutation) AddedTaskID() (r int64, exists bool) {
	v := m.addtask_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaskID clears the value of the "task_id" field.
func (m *ProcInstMutation) ClearTaskID() {
	m.task_id = nil
	m.addtask_id = nil
	m.clearedFields[procinst.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *ProcInstMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[procinst.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ProcInstMutation) ResetTaskID() {
	m.task_id = nil
	m.addtask_id = nil
	delete(m.clearedFields, procinst.FieldTaskID)
}

// SetStartTime sets the "start_time" field.
func (m *ProcInstMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ProcInstMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ProcInstMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[procinst.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ProcInstMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[procinst.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ProcInstMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, procinst.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ProcInstMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ProcInstMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ProcInstMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[procinst.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ProcInstMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[procinst.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ProcInstMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, procinst.FieldEndTime)
}

// SetStartUserID sets the "start_user_id" field.
func (m *ProcInstMutation) SetStartUserID(i int64) {
	m.start_user_id = &i
	m.addstart_user_id = nil
}

// StartUserID returns the value of the "start_user_id" field in the mutation.
func (m *ProcInstMutation) StartUserID() (r int64, exists bool) {
	v := m.start_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStartUserID returns the old "start_user_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldStartUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartUserID: %w", err)
	}
	return oldValue.StartUserID, nil
}

// AddStartUserID adds i to the "start_user_id" field.
func (m *ProcInstMutation) AddStartUserID(i int64) {
	if m.addstart_user_id != nil {
		*m.addstart_user_id += i
	} else {
		m.addstart_user_id = &i
	}
}

// AddedStartUserID returns the value that was added to the "start_user_id" field in this mutation.
func (m *ProcInstMutation) AddedStartUserID() (r int64, exists bool) {
	v := m.addstart_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartUserID clears the value of the "start_user_id" field.
func (m *ProcInstMutation) ClearStartUserID() {
	m.start_user_id = nil
	m.addstart_user_id = nil
	m.clearedFields[procinst.FieldStartUserID] = struct{}{}
}

// StartUserIDCleared returns if the "start_user_id" field was cleared in this mutation.
func (m *ProcInstMutation) StartUserIDCleared() bool {
	_, ok := m.clearedFields[procinst.FieldStartUserID]
	return ok
}

// ResetStartUserID resets all changes to the "start_user_id" field.
func (m *ProcInstMutation) ResetStartUserID() {
	m.start_user_id = nil
	m.addstart_user_id = nil
	delete(m.clearedFields, procinst.FieldStartUserID)
}

// SetStartUserName sets the "start_user_name" field.
func (m *ProcInstMutation) SetStartUserName(s string) {
	m.start_user_name = &s
}

// StartUserName returns the value of the "start_user_name" field in the mutation.
func (m *ProcInstMutation) StartUserName() (r string, exists bool) {
	v := m.start_user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStartUserName returns the old "start_user_name" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldStartUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartUserName: %w", err)
	}
	return oldValue.StartUserName, nil
}

// ClearStartUserName clears the value of the "start_user_name" field.
func (m *ProcInstMutation) ClearStartUserName() {
	m.start_user_name = nil
	m.clearedFields[procinst.FieldStartUserName] = struct{}{}
}

// StartUserNameCleared returns if the "start_user_name" field was cleared in this mutation.
func (m *ProcInstMutation) StartUserNameCleared() bool {
	_, ok := m.clearedFields[procinst.FieldStartUserName]
	return ok
}

// ResetStartUserName resets all changes to the "start_user_name" field.
func (m *ProcInstMutation) ResetStartUserName() {
	m.start_user_name = nil
	delete(m.clearedFields, procinst.FieldStartUserName)
}

// SetIsFinished sets the "is_finished" field.
func (m *ProcInstMutation) SetIsFinished(i int8) {
	m.is_finished = &i
	m.addis_finished = nil
}

// IsFinished returns the value of the "is_finished" field in the mutation.
func (m *ProcInstMutation) IsFinished() (r int8, exists bool) {
	v := m.is_finished
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFinished returns the old "is_finished" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldIsFinished(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFinished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFinished: %w", err)
	}
	return oldValue.IsFinished, nil
}

// AddIsFinished adds i to the "is_finished" field.
func (m *ProcInstMutation) AddIsFinished(i int8) {
	if m.addis_finished != nil {
		*m.addis_finished += i
	} else {
		m.addis_finished = &i
	}
}

// AddedIsFinished returns the value that was added to the "is_finished" field in this mutation.
func (m *ProcInstMutation) AddedIsFinished() (r int8, exists bool) {
	v := m.addis_finished
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsFinished clears the value of the "is_finished" field.
func (m *ProcInstMutation) ClearIsFinished() {
	m.is_finished = nil
	m.addis_finished = nil
	m.clearedFields[procinst.FieldIsFinished] = struct{}{}
}

// IsFinishedCleared returns if the "is_finished" field was cleared in this mutation.
func (m *ProcInstMutation) IsFinishedCleared() bool {
	_, ok := m.clearedFields[procinst.FieldIsFinished]
	return ok
}

// ResetIsFinished resets all changes to the "is_finished" field.
func (m *ProcInstMutation) ResetIsFinished() {
	m.is_finished = nil
	m.addis_finished = nil
	delete(m.clearedFields, procinst.FieldIsFinished)
}

// SetState sets the "state" field.
func (m *ProcInstMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *ProcInstMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *ProcInstMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *ProcInstMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ClearState clears the value of the "state" field.
func (m *ProcInstMutation) ClearState() {
	m.state = nil
	m.addstate = nil
	m.clearedFields[procinst.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *ProcInstMutation) StateCleared() bool {
	_, ok := m.clearedFields[procinst.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *ProcInstMutation) ResetState() {
	m.state = nil
	m.addstate = nil
	delete(m.clearedFields, procinst.FieldState)
}

// SetDataID sets the "data_id" field.
func (m *ProcInstMutation) SetDataID(i int64) {
	m.data_id = &i
	m.adddata_id = nil
}

// DataID returns the value of the "data_id" field in the mutation.
func (m *ProcInstMutation) DataID() (r int64, exists bool) {
	v := m.data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDataID returns the old "data_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldDataID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataID: %w", err)
	}
	return oldValue.DataID, nil
}

// AddDataID adds i to the "data_id" field.
func (m *ProcInstMutation) AddDataID(i int64) {
	if m.adddata_id != nil {
		*m.adddata_id += i
	} else {
		m.adddata_id = &i
	}
}

// AddedDataID returns the value that was added to the "data_id" field in this mutation.
func (m *ProcInstMutation) AddedDataID() (r int64, exists bool) {
	v := m.adddata_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDataID clears the value of the "data_id" field.
func (m *ProcInstMutation) ClearDataID() {
	m.data_id = nil
	m.adddata_id = nil
	m.clearedFields[procinst.FieldDataID] = struct{}{}
}

// DataIDCleared returns if the "data_id" field was cleared in this mutation.
func (m *ProcInstMutation) DataIDCleared() bool {
	_, ok := m.clearedFields[procinst.FieldDataID]
	return ok
}

// ResetDataID resets all changes to the "data_id" field.
func (m *ProcInstMutation) ResetDataID() {
	m.data_id = nil
	m.adddata_id = nil
	delete(m.clearedFields, procinst.FieldDataID)
}

// SetIsDel sets the "is_del" field.
func (m *ProcInstMutation) SetIsDel(i int) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *ProcInstMutation) IsDel() (r int, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldIsDel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *ProcInstMutation) AddIsDel(i int) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *ProcInstMutation) AddedIsDel() (r int, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsDel clears the value of the "is_del" field.
func (m *ProcInstMutation) ClearIsDel() {
	m.is_del = nil
	m.addis_del = nil
	m.clearedFields[procinst.FieldIsDel] = struct{}{}
}

// IsDelCleared returns if the "is_del" field was cleared in this mutation.
func (m *ProcInstMutation) IsDelCleared() bool {
	_, ok := m.clearedFields[procinst.FieldIsDel]
	return ok
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *ProcInstMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
	delete(m.clearedFields, procinst.FieldIsDel)
}

// SetCreateTime sets the "create_time" field.
func (m *ProcInstMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProcInstMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ProcInstMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[procinst.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ProcInstMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[procinst.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProcInstMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, procinst.FieldCreateTime)
}

// SetRemainHours sets the "remain_hours" field.
func (m *ProcInstMutation) SetRemainHours(i int) {
	m.remain_hours = &i
	m.addremain_hours = nil
}

// RemainHours returns the value of the "remain_hours" field in the mutation.
func (m *ProcInstMutation) RemainHours() (r int, exists bool) {
	v := m.remain_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainHours returns the old "remain_hours" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldRemainHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainHours: %w", err)
	}
	return oldValue.RemainHours, nil
}

// AddRemainHours adds i to the "remain_hours" field.
func (m *ProcInstMutation) AddRemainHours(i int) {
	if m.addremain_hours != nil {
		*m.addremain_hours += i
	} else {
		m.addremain_hours = &i
	}
}

// AddedRemainHours returns the value that was added to the "remain_hours" field in this mutation.
func (m *ProcInstMutation) AddedRemainHours() (r int, exists bool) {
	v := m.addremain_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemainHours clears the value of the "remain_hours" field.
func (m *ProcInstMutation) ClearRemainHours() {
	m.remain_hours = nil
	m.addremain_hours = nil
	m.clearedFields[procinst.FieldRemainHours] = struct{}{}
}

// RemainHoursCleared returns if the "remain_hours" field was cleared in this mutation.
func (m *ProcInstMutation) RemainHoursCleared() bool {
	_, ok := m.clearedFields[procinst.FieldRemainHours]
	return ok
}

// ResetRemainHours resets all changes to the "remain_hours" field.
func (m *ProcInstMutation) ResetRemainHours() {
	m.remain_hours = nil
	m.addremain_hours = nil
	delete(m.clearedFields, procinst.FieldRemainHours)
}

// SetUpdateTime sets the "update_time" field.
func (m *ProcInstMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProcInstMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *ProcInstMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[procinst.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *ProcInstMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[procinst.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProcInstMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, procinst.FieldUpdateTime)
}

// Where appends a list predicates to the ProcInstMutation builder.
func (m *ProcInstMutation) Where(ps ...predicate.ProcInst) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProcInstMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProcInst).
func (m *ProcInstMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcInstMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.proc_def_id != nil {
		fields = append(fields, procinst.FieldProcDefID)
	}
	if m.title != nil {
		fields = append(fields, procinst.FieldTitle)
	}
	if m.code != nil {
		fields = append(fields, procinst.FieldCode)
	}
	if m.target_id != nil {
		fields = append(fields, procinst.FieldTargetID)
	}
	if m.node_id != nil {
		fields = append(fields, procinst.FieldNodeID)
	}
	if m.task_id != nil {
		fields = append(fields, procinst.FieldTaskID)
	}
	if m.start_time != nil {
		fields = append(fields, procinst.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, procinst.FieldEndTime)
	}
	if m.start_user_id != nil {
		fields = append(fields, procinst.FieldStartUserID)
	}
	if m.start_user_name != nil {
		fields = append(fields, procinst.FieldStartUserName)
	}
	if m.is_finished != nil {
		fields = append(fields, procinst.FieldIsFinished)
	}
	if m.state != nil {
		fields = append(fields, procinst.FieldState)
	}
	if m.data_id != nil {
		fields = append(fields, procinst.FieldDataID)
	}
	if m.is_del != nil {
		fields = append(fields, procinst.FieldIsDel)
	}
	if m.create_time != nil {
		fields = append(fields, procinst.FieldCreateTime)
	}
	if m.remain_hours != nil {
		fields = append(fields, procinst.FieldRemainHours)
	}
	if m.update_time != nil {
		fields = append(fields, procinst.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcInstMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case procinst.FieldProcDefID:
		return m.ProcDefID()
	case procinst.FieldTitle:
		return m.Title()
	case procinst.FieldCode:
		return m.Code()
	case procinst.FieldTargetID:
		return m.TargetID()
	case procinst.FieldNodeID:
		return m.NodeID()
	case procinst.FieldTaskID:
		return m.TaskID()
	case procinst.FieldStartTime:
		return m.StartTime()
	case procinst.FieldEndTime:
		return m.EndTime()
	case procinst.FieldStartUserID:
		return m.StartUserID()
	case procinst.FieldStartUserName:
		return m.StartUserName()
	case procinst.FieldIsFinished:
		return m.IsFinished()
	case procinst.FieldState:
		return m.State()
	case procinst.FieldDataID:
		return m.DataID()
	case procinst.FieldIsDel:
		return m.IsDel()
	case procinst.FieldCreateTime:
		return m.CreateTime()
	case procinst.FieldRemainHours:
		return m.RemainHours()
	case procinst.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcInstMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case procinst.FieldProcDefID:
		return m.OldProcDefID(ctx)
	case procinst.FieldTitle:
		return m.OldTitle(ctx)
	case procinst.FieldCode:
		return m.OldCode(ctx)
	case procinst.FieldTargetID:
		return m.OldTargetID(ctx)
	case procinst.FieldNodeID:
		return m.OldNodeID(ctx)
	case procinst.FieldTaskID:
		return m.OldTaskID(ctx)
	case procinst.FieldStartTime:
		return m.OldStartTime(ctx)
	case procinst.FieldEndTime:
		return m.OldEndTime(ctx)
	case procinst.FieldStartUserID:
		return m.OldStartUserID(ctx)
	case procinst.FieldStartUserName:
		return m.OldStartUserName(ctx)
	case procinst.FieldIsFinished:
		return m.OldIsFinished(ctx)
	case procinst.FieldState:
		return m.OldState(ctx)
	case procinst.FieldDataID:
		return m.OldDataID(ctx)
	case procinst.FieldIsDel:
		return m.OldIsDel(ctx)
	case procinst.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case procinst.FieldRemainHours:
		return m.OldRemainHours(ctx)
	case procinst.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ProcInst field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcInstMutation) SetField(name string, value ent.Value) error {
	switch name {
	case procinst.FieldProcDefID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcDefID(v)
		return nil
	case procinst.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case procinst.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case procinst.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case procinst.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case procinst.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case procinst.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case procinst.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case procinst.FieldStartUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartUserID(v)
		return nil
	case procinst.FieldStartUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartUserName(v)
		return nil
	case procinst.FieldIsFinished:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFinished(v)
		return nil
	case procinst.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case procinst.FieldDataID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataID(v)
		return nil
	case procinst.FieldIsDel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case procinst.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case procinst.FieldRemainHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainHours(v)
		return nil
	case procinst.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProcInst field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcInstMutation) AddedFields() []string {
	var fields []string
	if m.addproc_def_id != nil {
		fields = append(fields, procinst.FieldProcDefID)
	}
	if m.addtarget_id != nil {
		fields = append(fields, procinst.FieldTargetID)
	}
	if m.addtask_id != nil {
		fields = append(fields, procinst.FieldTaskID)
	}
	if m.addstart_user_id != nil {
		fields = append(fields, procinst.FieldStartUserID)
	}
	if m.addis_finished != nil {
		fields = append(fields, procinst.FieldIsFinished)
	}
	if m.addstate != nil {
		fields = append(fields, procinst.FieldState)
	}
	if m.adddata_id != nil {
		fields = append(fields, procinst.FieldDataID)
	}
	if m.addis_del != nil {
		fields = append(fields, procinst.FieldIsDel)
	}
	if m.addremain_hours != nil {
		fields = append(fields, procinst.FieldRemainHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcInstMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case procinst.FieldProcDefID:
		return m.AddedProcDefID()
	case procinst.FieldTargetID:
		return m.AddedTargetID()
	case procinst.FieldTaskID:
		return m.AddedTaskID()
	case procinst.FieldStartUserID:
		return m.AddedStartUserID()
	case procinst.FieldIsFinished:
		return m.AddedIsFinished()
	case procinst.FieldState:
		return m.AddedState()
	case procinst.FieldDataID:
		return m.AddedDataID()
	case procinst.FieldIsDel:
		return m.AddedIsDel()
	case procinst.FieldRemainHours:
		return m.AddedRemainHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcInstMutation) AddField(name string, value ent.Value) error {
	switch name {
	case procinst.FieldProcDefID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcDefID(v)
		return nil
	case procinst.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetID(v)
		return nil
	case procinst.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskID(v)
		return nil
	case procinst.FieldStartUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartUserID(v)
		return nil
	case procinst.FieldIsFinished:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFinished(v)
		return nil
	case procinst.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case procinst.FieldDataID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDataID(v)
		return nil
	case procinst.FieldIsDel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	case procinst.FieldRemainHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainHours(v)
		return nil
	}
	return fmt.Errorf("unknown ProcInst numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcInstMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(procinst.FieldTitle) {
		fields = append(fields, procinst.FieldTitle)
	}
	if m.FieldCleared(procinst.FieldCode) {
		fields = append(fields, procinst.FieldCode)
	}
	if m.FieldCleared(procinst.FieldTargetID) {
		fields = append(fields, procinst.FieldTargetID)
	}
	if m.FieldCleared(procinst.FieldNodeID) {
		fields = append(fields, procinst.FieldNodeID)
	}
	if m.FieldCleared(procinst.FieldTaskID) {
		fields = append(fields, procinst.FieldTaskID)
	}
	if m.FieldCleared(procinst.FieldStartTime) {
		fields = append(fields, procinst.FieldStartTime)
	}
	if m.FieldCleared(procinst.FieldEndTime) {
		fields = append(fields, procinst.FieldEndTime)
	}
	if m.FieldCleared(procinst.FieldStartUserID) {
		fields = append(fields, procinst.FieldStartUserID)
	}
	if m.FieldCleared(procinst.FieldStartUserName) {
		fields = append(fields, procinst.FieldStartUserName)
	}
	if m.FieldCleared(procinst.FieldIsFinished) {
		fields = append(fields, procinst.FieldIsFinished)
	}
	if m.FieldCleared(procinst.FieldState) {
		fields = append(fields, procinst.FieldState)
	}
	if m.FieldCleared(procinst.FieldDataID) {
		fields = append(fields, procinst.FieldDataID)
	}
	if m.FieldCleared(procinst.FieldIsDel) {
		fields = append(fields, procinst.FieldIsDel)
	}
	if m.FieldCleared(procinst.FieldCreateTime) {
		fields = append(fields, procinst.FieldCreateTime)
	}
	if m.FieldCleared(procinst.FieldRemainHours) {
		fields = append(fields, procinst.FieldRemainHours)
	}
	if m.FieldCleared(procinst.FieldUpdateTime) {
		fields = append(fields, procinst.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcInstMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcInstMutation) ClearField(name string) error {
	switch name {
	case procinst.FieldTitle:
		m.ClearTitle()
		return nil
	case procinst.FieldCode:
		m.ClearCode()
		return nil
	case procinst.FieldTargetID:
		m.ClearTargetID()
		return nil
	case procinst.FieldNodeID:
		m.ClearNodeID()
		return nil
	case procinst.FieldTaskID:
		m.ClearTaskID()
		return nil
	case procinst.FieldStartTime:
		m.ClearStartTime()
		return nil
	case procinst.FieldEndTime:
		m.ClearEndTime()
		return nil
	case procinst.FieldStartUserID:
		m.ClearStartUserID()
		return nil
	case procinst.FieldStartUserName:
		m.ClearStartUserName()
		return nil
	case procinst.FieldIsFinished:
		m.ClearIsFinished()
		return nil
	case procinst.FieldState:
		m.ClearState()
		return nil
	case procinst.FieldDataID:
		m.ClearDataID()
		return nil
	case procinst.FieldIsDel:
		m.ClearIsDel()
		return nil
	case procinst.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case procinst.FieldRemainHours:
		m.ClearRemainHours()
		return nil
	case procinst.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ProcInst nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcInstMutation) ResetField(name string) error {
	switch name {
	case procinst.FieldProcDefID:
		m.ResetProcDefID()
		return nil
	case procinst.FieldTitle:
		m.ResetTitle()
		return nil
	case procinst.FieldCode:
		m.ResetCode()
		return nil
	case procinst.FieldTargetID:
		m.ResetTargetID()
		return nil
	case procinst.FieldNodeID:
		m.ResetNodeID()
		return nil
	case procinst.FieldTaskID:
		m.ResetTaskID()
		return nil
	case procinst.FieldStartTime:
		m.ResetStartTime()
		return nil
	case procinst.FieldEndTime:
		m.ResetEndTime()
		return nil
	case procinst.FieldStartUserID:
		m.ResetStartUserID()
		return nil
	case procinst.FieldStartUserName:
		m.ResetStartUserName()
		return nil
	case procinst.FieldIsFinished:
		m.ResetIsFinished()
		return nil
	case procinst.FieldState:
		m.ResetState()
		return nil
	case procinst.FieldDataID:
		m.ResetDataID()
		return nil
	case procinst.FieldIsDel:
		m.ResetIsDel()
		return nil
	case procinst.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case procinst.FieldRemainHours:
		m.ResetRemainHours()
		return nil
	case procinst.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ProcInst field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcInstMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcInstMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcInstMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcInstMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcInstMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcInstMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcInstMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcInst unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcInstMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcInst edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	node_id            *string
	level              *int
	addlevel           *int
	step               *int
	addstep            *int
	proc_inst_id       *int64
	addproc_inst_id    *int64
	create_time        *time.Time
	claim_time         *time.Time
	member_count       *int
	addmember_count    *int
	un_complete_num    *int
	addun_complete_num *int
	agree_num          *int
	addagree_num       *int
	is_finished        *int8
	addis_finished     *int8
	act_mode           *task.ActMode
	data_id            *int64
	adddata_id         *int64
	is_del             *int
	addis_del          *int
	update_time        *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Task, error)
	predicates         []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int64) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("act: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodeID sets the "node_id" field.
func (m *TaskMutation) SetNodeID(s string) {
	m.node_id = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *TaskMutation) NodeID() (r string, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ClearNodeID clears the value of the "node_id" field.
func (m *TaskMutation) ClearNodeID() {
	m.node_id = nil
	m.clearedFields[task.FieldNodeID] = struct{}{}
}

// NodeIDCleared returns if the "node_id" field was cleared in this mutation.
func (m *TaskMutation) NodeIDCleared() bool {
	_, ok := m.clearedFields[task.FieldNodeID]
	return ok
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *TaskMutation) ResetNodeID() {
	m.node_id = nil
	delete(m.clearedFields, task.FieldNodeID)
}

// SetLevel sets the "level" field.
func (m *TaskMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *TaskMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *TaskMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *TaskMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *TaskMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[task.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *TaskMutation) LevelCleared() bool {
	_, ok := m.clearedFields[task.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *TaskMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, task.FieldLevel)
}

// SetStep sets the "step" field.
func (m *TaskMutation) SetStep(i int) {
	m.step = &i
	m.addstep = nil
}

// Step returns the value of the "step" field in the mutation.
func (m *TaskMutation) Step() (r int, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStep returns the old "step" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStep: %w", err)
	}
	return oldValue.Step, nil
}

// AddStep adds i to the "step" field.
func (m *TaskMutation) AddStep(i int) {
	if m.addstep != nil {
		*m.addstep += i
	} else {
		m.addstep = &i
	}
}

// AddedStep returns the value that was added to the "step" field in this mutation.
func (m *TaskMutation) AddedStep() (r int, exists bool) {
	v := m.addstep
	if v == nil {
		return
	}
	return *v, true
}

// ClearStep clears the value of the "step" field.
func (m *TaskMutation) ClearStep() {
	m.step = nil
	m.addstep = nil
	m.clearedFields[task.FieldStep] = struct{}{}
}

// StepCleared returns if the "step" field was cleared in this mutation.
func (m *TaskMutation) StepCleared() bool {
	_, ok := m.clearedFields[task.FieldStep]
	return ok
}

// ResetStep resets all changes to the "step" field.
func (m *TaskMutation) ResetStep() {
	m.step = nil
	m.addstep = nil
	delete(m.clearedFields, task.FieldStep)
}

// SetProcInstID sets the "proc_inst_id" field.
func (m *TaskMutation) SetProcInstID(i int64) {
	m.proc_inst_id = &i
	m.addproc_inst_id = nil
}

// ProcInstID returns the value of the "proc_inst_id" field in the mutation.
func (m *TaskMutation) ProcInstID() (r int64, exists bool) {
	v := m.proc_inst_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcInstID returns the old "proc_inst_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldProcInstID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcInstID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcInstID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcInstID: %w", err)
	}
	return oldValue.ProcInstID, nil
}

// AddProcInstID adds i to the "proc_inst_id" field.
func (m *TaskMutation) AddProcInstID(i int64) {
	if m.addproc_inst_id != nil {
		*m.addproc_inst_id += i
	} else {
		m.addproc_inst_id = &i
	}
}

// AddedProcInstID returns the value that was added to the "proc_inst_id" field in this mutation.
func (m *TaskMutation) AddedProcInstID() (r int64, exists bool) {
	v := m.addproc_inst_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcInstID resets all changes to the "proc_inst_id" field.
func (m *TaskMutation) ResetProcInstID() {
	m.proc_inst_id = nil
	m.addproc_inst_id = nil
}

// SetCreateTime sets the "create_time" field.
func (m *TaskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TaskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *TaskMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[task.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *TaskMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TaskMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, task.FieldCreateTime)
}

// SetClaimTime sets the "claim_time" field.
func (m *TaskMutation) SetClaimTime(t time.Time) {
	m.claim_time = &t
}

// ClaimTime returns the value of the "claim_time" field in the mutation.
func (m *TaskMutation) ClaimTime() (r time.Time, exists bool) {
	v := m.claim_time
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimTime returns the old "claim_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldClaimTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimTime: %w", err)
	}
	return oldValue.ClaimTime, nil
}

// ClearClaimTime clears the value of the "claim_time" field.
func (m *TaskMutation) ClearClaimTime() {
	m.claim_time = nil
	m.clearedFields[task.FieldClaimTime] = struct{}{}
}

// ClaimTimeCleared returns if the "claim_time" field was cleared in this mutation.
func (m *TaskMutation) ClaimTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldClaimTime]
	return ok
}

// ResetClaimTime resets all changes to the "claim_time" field.
func (m *TaskMutation) ResetClaimTime() {
	m.claim_time = nil
	delete(m.clearedFields, task.FieldClaimTime)
}

// SetMemberCount sets the "member_count" field.
func (m *TaskMutation) SetMemberCount(i int) {
	m.member_count = &i
	m.addmember_count = nil
}

// MemberCount returns the value of the "member_count" field in the mutation.
func (m *TaskMutation) MemberCount() (r int, exists bool) {
	v := m.member_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberCount returns the old "member_count" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMemberCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberCount: %w", err)
	}
	return oldValue.MemberCount, nil
}

// AddMemberCount adds i to the "member_count" field.
func (m *TaskMutation) AddMemberCount(i int) {
	if m.addmember_count != nil {
		*m.addmember_count += i
	} else {
		m.addmember_count = &i
	}
}

// AddedMemberCount returns the value that was added to the "member_count" field in this mutation.
func (m *TaskMutation) AddedMemberCount() (r int, exists bool) {
	v := m.addmember_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberCount clears the value of the "member_count" field.
func (m *TaskMutation) ClearMemberCount() {
	m.member_count = nil
	m.addmember_count = nil
	m.clearedFields[task.FieldMemberCount] = struct{}{}
}

// MemberCountCleared returns if the "member_count" field was cleared in this mutation.
func (m *TaskMutation) MemberCountCleared() bool {
	_, ok := m.clearedFields[task.FieldMemberCount]
	return ok
}

// ResetMemberCount resets all changes to the "member_count" field.
func (m *TaskMutation) ResetMemberCount() {
	m.member_count = nil
	m.addmember_count = nil
	delete(m.clearedFields, task.FieldMemberCount)
}

// SetUnCompleteNum sets the "un_complete_num" field.
func (m *TaskMutation) SetUnCompleteNum(i int) {
	m.un_complete_num = &i
	m.addun_complete_num = nil
}

// UnCompleteNum returns the value of the "un_complete_num" field in the mutation.
func (m *TaskMutation) UnCompleteNum() (r int, exists bool) {
	v := m.un_complete_num
	if v == nil {
		return
	}
	return *v, true
}

// OldUnCompleteNum returns the old "un_complete_num" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUnCompleteNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnCompleteNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnCompleteNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnCompleteNum: %w", err)
	}
	return oldValue.UnCompleteNum, nil
}

// AddUnCompleteNum adds i to the "un_complete_num" field.
func (m *TaskMutation) AddUnCompleteNum(i int) {
	if m.addun_complete_num != nil {
		*m.addun_complete_num += i
	} else {
		m.addun_complete_num = &i
	}
}

// AddedUnCompleteNum returns the value that was added to the "un_complete_num" field in this mutation.
func (m *TaskMutation) AddedUnCompleteNum() (r int, exists bool) {
	v := m.addun_complete_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnCompleteNum clears the value of the "un_complete_num" field.
func (m *TaskMutation) ClearUnCompleteNum() {
	m.un_complete_num = nil
	m.addun_complete_num = nil
	m.clearedFields[task.FieldUnCompleteNum] = struct{}{}
}

// UnCompleteNumCleared returns if the "un_complete_num" field was cleared in this mutation.
func (m *TaskMutation) UnCompleteNumCleared() bool {
	_, ok := m.clearedFields[task.FieldUnCompleteNum]
	return ok
}

// ResetUnCompleteNum resets all changes to the "un_complete_num" field.
func (m *TaskMutation) ResetUnCompleteNum() {
	m.un_complete_num = nil
	m.addun_complete_num = nil
	delete(m.clearedFields, task.FieldUnCompleteNum)
}

// SetAgreeNum sets the "agree_num" field.
func (m *TaskMutation) SetAgreeNum(i int) {
	m.agree_num = &i
	m.addagree_num = nil
}

// AgreeNum returns the value of the "agree_num" field in the mutation.
func (m *TaskMutation) AgreeNum() (r int, exists bool) {
	v := m.agree_num
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreeNum returns the old "agree_num" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAgreeNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreeNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreeNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreeNum: %w", err)
	}
	return oldValue.AgreeNum, nil
}

// AddAgreeNum adds i to the "agree_num" field.
func (m *TaskMutation) AddAgreeNum(i int) {
	if m.addagree_num != nil {
		*m.addagree_num += i
	} else {
		m.addagree_num = &i
	}
}

// AddedAgreeNum returns the value that was added to the "agree_num" field in this mutation.
func (m *TaskMutation) AddedAgreeNum() (r int, exists bool) {
	v := m.addagree_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearAgreeNum clears the value of the "agree_num" field.
func (m *TaskMutation) ClearAgreeNum() {
	m.agree_num = nil
	m.addagree_num = nil
	m.clearedFields[task.FieldAgreeNum] = struct{}{}
}

// AgreeNumCleared returns if the "agree_num" field was cleared in this mutation.
func (m *TaskMutation) AgreeNumCleared() bool {
	_, ok := m.clearedFields[task.FieldAgreeNum]
	return ok
}

// ResetAgreeNum resets all changes to the "agree_num" field.
func (m *TaskMutation) ResetAgreeNum() {
	m.agree_num = nil
	m.addagree_num = nil
	delete(m.clearedFields, task.FieldAgreeNum)
}

// SetIsFinished sets the "is_finished" field.
func (m *TaskMutation) SetIsFinished(i int8) {
	m.is_finished = &i
	m.addis_finished = nil
}

// IsFinished returns the value of the "is_finished" field in the mutation.
func (m *TaskMutation) IsFinished() (r int8, exists bool) {
	v := m.is_finished
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFinished returns the old "is_finished" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsFinished(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFinished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFinished: %w", err)
	}
	return oldValue.IsFinished, nil
}

// AddIsFinished adds i to the "is_finished" field.
func (m *TaskMutation) AddIsFinished(i int8) {
	if m.addis_finished != nil {
		*m.addis_finished += i
	} else {
		m.addis_finished = &i
	}
}

// AddedIsFinished returns the value that was added to the "is_finished" field in this mutation.
func (m *TaskMutation) AddedIsFinished() (r int8, exists bool) {
	v := m.addis_finished
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsFinished clears the value of the "is_finished" field.
func (m *TaskMutation) ClearIsFinished() {
	m.is_finished = nil
	m.addis_finished = nil
	m.clearedFields[task.FieldIsFinished] = struct{}{}
}

// IsFinishedCleared returns if the "is_finished" field was cleared in this mutation.
func (m *TaskMutation) IsFinishedCleared() bool {
	_, ok := m.clearedFields[task.FieldIsFinished]
	return ok
}

// ResetIsFinished resets all changes to the "is_finished" field.
func (m *TaskMutation) ResetIsFinished() {
	m.is_finished = nil
	m.addis_finished = nil
	delete(m.clearedFields, task.FieldIsFinished)
}

// SetActMode sets the "act_mode" field.
func (m *TaskMutation) SetActMode(tt task.ActMode) {
	m.act_mode = &tt
}

// ActMode returns the value of the "act_mode" field in the mutation.
func (m *TaskMutation) ActMode() (r task.ActMode, exists bool) {
	v := m.act_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldActMode returns the old "act_mode" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldActMode(ctx context.Context) (v task.ActMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActMode: %w", err)
	}
	return oldValue.ActMode, nil
}

// ClearActMode clears the value of the "act_mode" field.
func (m *TaskMutation) ClearActMode() {
	m.act_mode = nil
	m.clearedFields[task.FieldActMode] = struct{}{}
}

// ActModeCleared returns if the "act_mode" field was cleared in this mutation.
func (m *TaskMutation) ActModeCleared() bool {
	_, ok := m.clearedFields[task.FieldActMode]
	return ok
}

// ResetActMode resets all changes to the "act_mode" field.
func (m *TaskMutation) ResetActMode() {
	m.act_mode = nil
	delete(m.clearedFields, task.FieldActMode)
}

// SetDataID sets the "data_id" field.
func (m *TaskMutation) SetDataID(i int64) {
	m.data_id = &i
	m.adddata_id = nil
}

// DataID returns the value of the "data_id" field in the mutation.
func (m *TaskMutation) DataID() (r int64, exists bool) {
	v := m.data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDataID returns the old "data_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDataID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataID: %w", err)
	}
	return oldValue.DataID, nil
}

// AddDataID adds i to the "data_id" field.
func (m *TaskMutation) AddDataID(i int64) {
	if m.adddata_id != nil {
		*m.adddata_id += i
	} else {
		m.adddata_id = &i
	}
}

// AddedDataID returns the value that was added to the "data_id" field in this mutation.
func (m *TaskMutation) AddedDataID() (r int64, exists bool) {
	v := m.adddata_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDataID clears the value of the "data_id" field.
func (m *TaskMutation) ClearDataID() {
	m.data_id = nil
	m.adddata_id = nil
	m.clearedFields[task.FieldDataID] = struct{}{}
}

// DataIDCleared returns if the "data_id" field was cleared in this mutation.
func (m *TaskMutation) DataIDCleared() bool {
	_, ok := m.clearedFields[task.FieldDataID]
	return ok
}

// ResetDataID resets all changes to the "data_id" field.
func (m *TaskMutation) ResetDataID() {
	m.data_id = nil
	m.adddata_id = nil
	delete(m.clearedFields, task.FieldDataID)
}

// SetIsDel sets the "is_del" field.
func (m *TaskMutation) SetIsDel(i int) {
	m.is_del = &i
	m.addis_del = nil
}

// IsDel returns the value of the "is_del" field in the mutation.
func (m *TaskMutation) IsDel() (r int, exists bool) {
	v := m.is_del
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDel returns the old "is_del" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsDel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDel: %w", err)
	}
	return oldValue.IsDel, nil
}

// AddIsDel adds i to the "is_del" field.
func (m *TaskMutation) AddIsDel(i int) {
	if m.addis_del != nil {
		*m.addis_del += i
	} else {
		m.addis_del = &i
	}
}

// AddedIsDel returns the value that was added to the "is_del" field in this mutation.
func (m *TaskMutation) AddedIsDel() (r int, exists bool) {
	v := m.addis_del
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsDel clears the value of the "is_del" field.
func (m *TaskMutation) ClearIsDel() {
	m.is_del = nil
	m.addis_del = nil
	m.clearedFields[task.FieldIsDel] = struct{}{}
}

// IsDelCleared returns if the "is_del" field was cleared in this mutation.
func (m *TaskMutation) IsDelCleared() bool {
	_, ok := m.clearedFields[task.FieldIsDel]
	return ok
}

// ResetIsDel resets all changes to the "is_del" field.
func (m *TaskMutation) ResetIsDel() {
	m.is_del = nil
	m.addis_del = nil
	delete(m.clearedFields, task.FieldIsDel)
}

// SetUpdateTime sets the "update_time" field.
func (m *TaskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TaskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *TaskMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[task.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *TaskMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TaskMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, task.FieldUpdateTime)
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.node_id != nil {
		fields = append(fields, task.FieldNodeID)
	}
	if m.level != nil {
		fields = append(fields, task.FieldLevel)
	}
	if m.step != nil {
		fields = append(fields, task.FieldStep)
	}
	if m.proc_inst_id != nil {
		fields = append(fields, task.FieldProcInstID)
	}
	if m.create_time != nil {
		fields = append(fields, task.FieldCreateTime)
	}
	if m.claim_time != nil {
		fields = append(fields, task.FieldClaimTime)
	}
	if m.member_count != nil {
		fields = append(fields, task.FieldMemberCount)
	}
	if m.un_complete_num != nil {
		fields = append(fields, task.FieldUnCompleteNum)
	}
	if m.agree_num != nil {
		fields = append(fields, task.FieldAgreeNum)
	}
	if m.is_finished != nil {
		fields = append(fields, task.FieldIsFinished)
	}
	if m.act_mode != nil {
		fields = append(fields, task.FieldActMode)
	}
	if m.data_id != nil {
		fields = append(fields, task.FieldDataID)
	}
	if m.is_del != nil {
		fields = append(fields, task.FieldIsDel)
	}
	if m.update_time != nil {
		fields = append(fields, task.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldNodeID:
		return m.NodeID()
	case task.FieldLevel:
		return m.Level()
	case task.FieldStep:
		return m.Step()
	case task.FieldProcInstID:
		return m.ProcInstID()
	case task.FieldCreateTime:
		return m.CreateTime()
	case task.FieldClaimTime:
		return m.ClaimTime()
	case task.FieldMemberCount:
		return m.MemberCount()
	case task.FieldUnCompleteNum:
		return m.UnCompleteNum()
	case task.FieldAgreeNum:
		return m.AgreeNum()
	case task.FieldIsFinished:
		return m.IsFinished()
	case task.FieldActMode:
		return m.ActMode()
	case task.FieldDataID:
		return m.DataID()
	case task.FieldIsDel:
		return m.IsDel()
	case task.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldNodeID:
		return m.OldNodeID(ctx)
	case task.FieldLevel:
		return m.OldLevel(ctx)
	case task.FieldStep:
		return m.OldStep(ctx)
	case task.FieldProcInstID:
		return m.OldProcInstID(ctx)
	case task.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case task.FieldClaimTime:
		return m.OldClaimTime(ctx)
	case task.FieldMemberCount:
		return m.OldMemberCount(ctx)
	case task.FieldUnCompleteNum:
		return m.OldUnCompleteNum(ctx)
	case task.FieldAgreeNum:
		return m.OldAgreeNum(ctx)
	case task.FieldIsFinished:
		return m.OldIsFinished(ctx)
	case task.FieldActMode:
		return m.OldActMode(ctx)
	case task.FieldDataID:
		return m.OldDataID(ctx)
	case task.FieldIsDel:
		return m.OldIsDel(ctx)
	case task.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case task.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case task.FieldStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStep(v)
		return nil
	case task.FieldProcInstID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcInstID(v)
		return nil
	case task.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case task.FieldClaimTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimTime(v)
		return nil
	case task.FieldMemberCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberCount(v)
		return nil
	case task.FieldUnCompleteNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnCompleteNum(v)
		return nil
	case task.FieldAgreeNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreeNum(v)
		return nil
	case task.FieldIsFinished:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFinished(v)
		return nil
	case task.FieldActMode:
		v, ok := value.(task.ActMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActMode(v)
		return nil
	case task.FieldDataID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataID(v)
		return nil
	case task.FieldIsDel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDel(v)
		return nil
	case task.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, task.FieldLevel)
	}
	if m.addstep != nil {
		fields = append(fields, task.FieldStep)
	}
	if m.addproc_inst_id != nil {
		fields = append(fields, task.FieldProcInstID)
	}
	if m.addmember_count != nil {
		fields = append(fields, task.FieldMemberCount)
	}
	if m.addun_complete_num != nil {
		fields = append(fields, task.FieldUnCompleteNum)
	}
	if m.addagree_num != nil {
		fields = append(fields, task.FieldAgreeNum)
	}
	if m.addis_finished != nil {
		fields = append(fields, task.FieldIsFinished)
	}
	if m.adddata_id != nil {
		fields = append(fields, task.FieldDataID)
	}
	if m.addis_del != nil {
		fields = append(fields, task.FieldIsDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldLevel:
		return m.AddedLevel()
	case task.FieldStep:
		return m.AddedStep()
	case task.FieldProcInstID:
		return m.AddedProcInstID()
	case task.FieldMemberCount:
		return m.AddedMemberCount()
	case task.FieldUnCompleteNum:
		return m.AddedUnCompleteNum()
	case task.FieldAgreeNum:
		return m.AddedAgreeNum()
	case task.FieldIsFinished:
		return m.AddedIsFinished()
	case task.FieldDataID:
		return m.AddedDataID()
	case task.FieldIsDel:
		return m.AddedIsDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case task.FieldStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStep(v)
		return nil
	case task.FieldProcInstID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcInstID(v)
		return nil
	case task.FieldMemberCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberCount(v)
		return nil
	case task.FieldUnCompleteNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnCompleteNum(v)
		return nil
	case task.FieldAgreeNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgreeNum(v)
		return nil
	case task.FieldIsFinished:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFinished(v)
		return nil
	case task.FieldDataID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDataID(v)
		return nil
	case task.FieldIsDel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDel(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldNodeID) {
		fields = append(fields, task.FieldNodeID)
	}
	if m.FieldCleared(task.FieldLevel) {
		fields = append(fields, task.FieldLevel)
	}
	if m.FieldCleared(task.FieldStep) {
		fields = append(fields, task.FieldStep)
	}
	if m.FieldCleared(task.FieldCreateTime) {
		fields = append(fields, task.FieldCreateTime)
	}
	if m.FieldCleared(task.FieldClaimTime) {
		fields = append(fields, task.FieldClaimTime)
	}
	if m.FieldCleared(task.FieldMemberCount) {
		fields = append(fields, task.FieldMemberCount)
	}
	if m.FieldCleared(task.FieldUnCompleteNum) {
		fields = append(fields, task.FieldUnCompleteNum)
	}
	if m.FieldCleared(task.FieldAgreeNum) {
		fields = append(fields, task.FieldAgreeNum)
	}
	if m.FieldCleared(task.FieldIsFinished) {
		fields = append(fields, task.FieldIsFinished)
	}
	if m.FieldCleared(task.FieldActMode) {
		fields = append(fields, task.FieldActMode)
	}
	if m.FieldCleared(task.FieldDataID) {
		fields = append(fields, task.FieldDataID)
	}
	if m.FieldCleared(task.FieldIsDel) {
		fields = append(fields, task.FieldIsDel)
	}
	if m.FieldCleared(task.FieldUpdateTime) {
		fields = append(fields, task.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldNodeID:
		m.ClearNodeID()
		return nil
	case task.FieldLevel:
		m.ClearLevel()
		return nil
	case task.FieldStep:
		m.ClearStep()
		return nil
	case task.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case task.FieldClaimTime:
		m.ClearClaimTime()
		return nil
	case task.FieldMemberCount:
		m.ClearMemberCount()
		return nil
	case task.FieldUnCompleteNum:
		m.ClearUnCompleteNum()
		return nil
	case task.FieldAgreeNum:
		m.ClearAgreeNum()
		return nil
	case task.FieldIsFinished:
		m.ClearIsFinished()
		return nil
	case task.FieldActMode:
		m.ClearActMode()
		return nil
	case task.FieldDataID:
		m.ClearDataID()
		return nil
	case task.FieldIsDel:
		m.ClearIsDel()
		return nil
	case task.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldNodeID:
		m.ResetNodeID()
		return nil
	case task.FieldLevel:
		m.ResetLevel()
		return nil
	case task.FieldStep:
		m.ResetStep()
		return nil
	case task.FieldProcInstID:
		m.ResetProcInstID()
		return nil
	case task.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case task.FieldClaimTime:
		m.ResetClaimTime()
		return nil
	case task.FieldMemberCount:
		m.ResetMemberCount()
		return nil
	case task.FieldUnCompleteNum:
		m.ResetUnCompleteNum()
		return nil
	case task.FieldAgreeNum:
		m.ResetAgreeNum()
		return nil
	case task.FieldIsFinished:
		m.ResetIsFinished()
		return nil
	case task.FieldActMode:
		m.ResetActMode()
		return nil
	case task.FieldDataID:
		m.ResetDataID()
		return nil
	case task.FieldIsDel:
		m.ResetIsDel()
		return nil
	case task.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Task edge %s", name)
}
