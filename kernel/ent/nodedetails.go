// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"go-wflow/kernel"
	"go-wflow/kernel/ent/nodedetails"
	"strings"
	"time"

	"github.com/qkbyte/ent/dialect/sql"
)

// NodeDetails is the model entity for the NodeDetails schema.
type NodeDetails struct {
	config `json:"-"`
	// ID of the ent.
	// 雪花id
	ID uint64 `json:"id"`
	// ProcInstID holds the value of the "procInstID" field.
	// 流程实例id
	ProcInstID uint64 `json:"procInstID"`
	// NodeID holds the value of the "nodeID" field.
	// 节点id
	NodeID string `json:"nodeID"`
	// NodeInfo holds the value of the "nodeInfo" field.
	// 节点信息
	NodeInfo string `json:"nodeInfo"`
	// Refuse holds the value of the "refuse" field.
	// 拒绝策略 直接结束、驳回至上一级、驳回至指定人
	Refuse string `json:"refuse"`
	// PrevID holds the value of the "prevID" field.
	// 上一节点ID
	PrevID string `json:"prevID"`
	// NextID holds the value of the "nextID" field.
	// 下一节点ID
	NextID string `json:"nextID"`
	// Mode holds the value of the "mode" field.
	// 会签or或签
	Mode string `json:"mode"`
	// CreateTime holds the value of the "createTime" field.
	// 流程创建时间
	CreateTime time.Time `json:"createTime"`
	// UpdateTime holds the value of the "updateTime" field.
	// 流程修改时间
	UpdateTime time.Time `json:"updateTime"`
	// CreateUser holds the value of the "createUser" field.
	// 创建人id
	CreateUser uint64 `json:"createUser"`
	// UpdateUser holds the value of the "updateUser" field.
	// 修改人id
	UpdateUser uint64 `json:"updateUser"`
	// Version holds the value of the "version" field.
	// 版本
	Version uint64 `json:"version"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*NodeDetails) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case nodedetails.FieldID, nodedetails.FieldProcInstID, nodedetails.FieldCreateUser, nodedetails.FieldUpdateUser, nodedetails.FieldVersion:
			values[i] = new(sql.NullInt64)
		case nodedetails.FieldNodeID, nodedetails.FieldNodeInfo, nodedetails.FieldRefuse, nodedetails.FieldPrevID, nodedetails.FieldNextID, nodedetails.FieldMode:
			values[i] = new(sql.NullString)
		case nodedetails.FieldCreateTime, nodedetails.FieldUpdateTime:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("意外的列 %q 对于类型 NodeDetails", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the NodeDetails fields.
func (nd *NodeDetails) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("扫描值数目不匹配: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case nodedetails.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("意外类型 %T 对于字段 id", value)
			}
			nd.ID = uint64(value.Int64)
		case nodedetails.FieldProcInstID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 procInstID", values[i])
			} else if value.Valid {
				nd.ProcInstID = uint64(value.Int64)
			}
		case nodedetails.FieldNodeID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 nodeID", values[i])
			} else if value.Valid {
				nd.NodeID = value.String
			}
		case nodedetails.FieldNodeInfo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 nodeInfo", values[i])
			} else if value.Valid {
				nd.NodeInfo = value.String
			}
		case nodedetails.FieldRefuse:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 refuse", values[i])
			} else if value.Valid {
				nd.Refuse = value.String
			}
		case nodedetails.FieldPrevID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 prevID", values[i])
			} else if value.Valid {
				nd.PrevID = value.String
			}
		case nodedetails.FieldNextID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 nextID", values[i])
			} else if value.Valid {
				nd.NextID = value.String
			}
		case nodedetails.FieldMode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 mode", values[i])
			} else if value.Valid {
				nd.Mode = value.String
			}
		case nodedetails.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 createTime", values[i])
			} else if value.Valid {
				nd.CreateTime = value.Time
			}
		case nodedetails.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 updateTime", values[i])
			} else if value.Valid {
				nd.UpdateTime = value.Time
			}
		case nodedetails.FieldCreateUser:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 createUser", values[i])
			} else if value.Valid {
				nd.CreateUser = uint64(value.Int64)
			}
		case nodedetails.FieldUpdateUser:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 updateUser", values[i])
			} else if value.Valid {
				nd.UpdateUser = uint64(value.Int64)
			}
		case nodedetails.FieldVersion:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("意外类型 %T 对于字段 version", values[i])
			} else if value.Valid {
				nd.Version = uint64(value.Int64)
			}
		}
	}
	return nil
}

// Update returns a builder for updating this NodeDetails.
// Note that you need to call NodeDetails.Unwrap() before calling this method if this NodeDetails
// was returned from a transaction, and the transaction was committed or rolled back.
func (nd *NodeDetails) Update(u uint64) *NodeDetailsUpdateOne {
	return (&NodeDetailsClient{config: nd.config}).UpdateOne(nd, u)
}

// Unwrap unwraps the NodeDetails entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (nd *NodeDetails) Unwrap() *NodeDetails {
	tx, ok := nd.config.driver.(*txDriver)
	if !ok {
		panic("ent: NodeDetails is not a transactional entity")
	}
	nd.config.driver = tx.drv
	return nd
}

// String implements the fmt.Stringer.
func (nd *NodeDetails) String() string {
	var builder strings.Builder
	builder.WriteString("NodeDetails(")
	builder.WriteString(fmt.Sprintf("id=%v", nd.ID))
	builder.WriteString(", procInstID=")
	builder.WriteString(fmt.Sprintf("%v", nd.ProcInstID))
	builder.WriteString(", nodeID=")
	builder.WriteString(nd.NodeID)
	builder.WriteString(", nodeInfo=")
	builder.WriteString(nd.NodeInfo)
	builder.WriteString(", refuse=")
	builder.WriteString(nd.Refuse)
	builder.WriteString(", prevID=")
	builder.WriteString(nd.PrevID)
	builder.WriteString(", nextID=")
	builder.WriteString(nd.NextID)
	builder.WriteString(", mode=")
	builder.WriteString(nd.Mode)
	builder.WriteString(", createTime=")
	builder.WriteString(nd.CreateTime.Format(time.ANSIC))
	builder.WriteString(", updateTime=")
	builder.WriteString(nd.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", createUser=")
	builder.WriteString(fmt.Sprintf("%v", nd.CreateUser))
	builder.WriteString(", updateUser=")
	builder.WriteString(fmt.Sprintf("%v", nd.UpdateUser))
	builder.WriteString(", version=")
	builder.WriteString(fmt.Sprintf("%v", nd.Version))
	builder.WriteByte(')')
	return builder.String()
}

// ToMessage returns grpc message
func (t *NodeDetails) ToMessage() *kernel.NodeDetails {
	k := &kernel.NodeDetails{
		Id:         t.ID,
		ProcInstID: t.ProcInstID,
		NodeID:     t.NodeID,
		NodeInfo:   t.NodeInfo,
		Refuse:     t.Refuse,
		PrevID:     t.PrevID,
		NextID:     t.NextID,
		Mode:       t.Mode,
		CreateTime: t.CreateTime.String(),
		UpdateTime: t.UpdateTime.String(),
		CreateUser: t.CreateUser,
		UpdateUser: t.UpdateUser,
		Version:    t.Version,
	}
	return k
}

// NodeDetailsSlice is a parsable slice of NodeDetails.
type NodeDetailsSlice []*NodeDetails

func (nd NodeDetailsSlice) config(cfg config) {
	for _i := range nd {
		nd[_i].config = cfg
	}
}
